//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.3.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class Client {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param sortfield (optional) 
     * @param sortorder (optional) 
     * @param limit (optional) 
     * @param page (optional) 
     * @param user_ids (optional) 
     * @param sqlFilters (optional) 
     * @return Success
     */
    agendaEventsAll(sortfield: string | undefined, sortorder: string | undefined, limit: number | undefined, page: number | undefined, user_ids: string | undefined, sqlFilters: string | undefined): Promise<AgendaEventDto[]> {
        let url_ = this.baseUrl + "/api/AgendaEvents?";
        if (sortfield === null)
            throw new Error("The parameter 'sortfield' cannot be null.");
        else if (sortfield !== undefined)
            url_ += "sortfield=" + encodeURIComponent("" + sortfield) + "&";
        if (sortorder === null)
            throw new Error("The parameter 'sortorder' cannot be null.");
        else if (sortorder !== undefined)
            url_ += "sortorder=" + encodeURIComponent("" + sortorder) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (user_ids === null)
            throw new Error("The parameter 'user_ids' cannot be null.");
        else if (user_ids !== undefined)
            url_ += "user_ids=" + encodeURIComponent("" + user_ids) + "&";
        if (sqlFilters === null)
            throw new Error("The parameter 'sqlFilters' cannot be null.");
        else if (sqlFilters !== undefined)
            url_ += "sqlFilters=" + encodeURIComponent("" + sqlFilters) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAgendaEventsAll(_response);
        });
    }

    protected processAgendaEventsAll(response: Response): Promise<AgendaEventDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AgendaEventDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AgendaEventDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    agendaEventsPOST(body: AgendaEventDto | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/AgendaEvents";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAgendaEventsPOST(_response);
        });
    }

    protected processAgendaEventsPOST(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @return Success
     */
    agendaEventsGET(id: number): Promise<AgendaEventDto> {
        let url_ = this.baseUrl + "/api/AgendaEvents/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAgendaEventsGET(_response);
        });
    }

    protected processAgendaEventsGET(response: Response): Promise<AgendaEventDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AgendaEventDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AgendaEventDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    agendaEventsPUT(id: number, body: AgendaEventDto | undefined): Promise<AgendaEventDto> {
        let url_ = this.baseUrl + "/api/AgendaEvents/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAgendaEventsPUT(_response);
        });
    }

    protected processAgendaEventsPUT(response: Response): Promise<AgendaEventDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AgendaEventDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AgendaEventDto>(null as any);
    }

    /**
     * @return Success
     */
    agendaEventsDELETE(id: number): Promise<string> {
        let url_ = this.baseUrl + "/api/AgendaEvents/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAgendaEventsDELETE(_response);
        });
    }

    protected processAgendaEventsDELETE(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @param sortfield (optional) 
     * @param sortorder (optional) 
     * @param limit (optional) 
     * @param page (optional) 
     * @param sqlFilters (optional) 
     * @return Success
     */
    billsOfMaterialsAll(sortfield?: string | undefined, sortorder?: string | undefined, limit?: number | undefined, page?: number | undefined, sqlFilters?: string | undefined): Promise<BillOfMaterialDto[]> {
        let url_ = this.baseUrl + "/api/BillsOfMaterials?";
        if (sortfield === null)
            throw new Error("The parameter 'sortfield' cannot be null.");
        else if (sortfield !== undefined)
            url_ += "sortfield=" + encodeURIComponent("" + sortfield) + "&";
        if (sortorder === null)
            throw new Error("The parameter 'sortorder' cannot be null.");
        else if (sortorder !== undefined)
            url_ += "sortorder=" + encodeURIComponent("" + sortorder) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (sqlFilters === null)
            throw new Error("The parameter 'sqlFilters' cannot be null.");
        else if (sqlFilters !== undefined)
            url_ += "sqlFilters=" + encodeURIComponent("" + sqlFilters) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBillsOfMaterialsAll(_response);
        });
    }

    protected processBillsOfMaterialsAll(response: Response): Promise<BillOfMaterialDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BillOfMaterialDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BillOfMaterialDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    billsOfMaterialsPOST(body: BillOfMaterialDto | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/BillsOfMaterials";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBillsOfMaterialsPOST(_response);
        });
    }

    protected processBillsOfMaterialsPOST(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @return Success
     */
    billsOfMaterialsGET(id: number): Promise<BillOfMaterialDto> {
        let url_ = this.baseUrl + "/api/BillsOfMaterials/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBillsOfMaterialsGET(_response);
        });
    }

    protected processBillsOfMaterialsGET(response: Response): Promise<BillOfMaterialDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BillOfMaterialDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BillOfMaterialDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    billsOfMaterialsPUT(id: number, body: BillOfMaterialDto | undefined): Promise<BillOfMaterialDto> {
        let url_ = this.baseUrl + "/api/BillsOfMaterials/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBillsOfMaterialsPUT(_response);
        });
    }

    protected processBillsOfMaterialsPUT(response: Response): Promise<BillOfMaterialDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BillOfMaterialDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BillOfMaterialDto>(null as any);
    }

    /**
     * @return Success
     */
    billsOfMaterialsDELETE(id: number): Promise<string> {
        let url_ = this.baseUrl + "/api/BillsOfMaterials/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBillsOfMaterialsDELETE(_response);
        });
    }

    protected processBillsOfMaterialsDELETE(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @param sortfield (optional) 
     * @param sortorder (optional) 
     * @param limit (optional) 
     * @param page (optional) 
     * @param type (optional) 
     * @param sqlfilters (optional) 
     * @return Success
     */
    categoriesAll(sortfield?: string | undefined, sortorder?: string | undefined, limit?: number | undefined, page?: number | undefined, type?: string | undefined, sqlfilters?: string | undefined): Promise<CategoryDto[]> {
        let url_ = this.baseUrl + "/api/Categories?";
        if (sortfield === null)
            throw new Error("The parameter 'sortfield' cannot be null.");
        else if (sortfield !== undefined)
            url_ += "sortfield=" + encodeURIComponent("" + sortfield) + "&";
        if (sortorder === null)
            throw new Error("The parameter 'sortorder' cannot be null.");
        else if (sortorder !== undefined)
            url_ += "sortorder=" + encodeURIComponent("" + sortorder) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        if (sqlfilters === null)
            throw new Error("The parameter 'sqlfilters' cannot be null.");
        else if (sqlfilters !== undefined)
            url_ += "sqlfilters=" + encodeURIComponent("" + sqlfilters) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCategoriesAll(_response);
        });
    }

    protected processCategoriesAll(response: Response): Promise<CategoryDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CategoryDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CategoryDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    categoriesPOST(body: CategoryDto | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/Categories";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCategoriesPOST(_response);
        });
    }

    protected processCategoriesPOST(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @return Success
     */
    categoriesGET(id: number): Promise<CategoryDto> {
        let url_ = this.baseUrl + "/api/Categories/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCategoriesGET(_response);
        });
    }

    protected processCategoriesGET(response: Response): Promise<CategoryDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CategoryDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CategoryDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    categoriesPUT(id: number, body: CategoryDto | undefined): Promise<CategoryDto> {
        let url_ = this.baseUrl + "/api/Categories/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCategoriesPUT(_response);
        });
    }

    protected processCategoriesPUT(response: Response): Promise<CategoryDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CategoryDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CategoryDto>(null as any);
    }

    /**
     * @return Success
     */
    categoriesDELETE(id: number): Promise<string> {
        let url_ = this.baseUrl + "/api/Categories/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCategoriesDELETE(_response);
        });
    }

    protected processCategoriesDELETE(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @param sortfield (optional) 
     * @param sortorder (optional) 
     * @param limit (optional) 
     * @param page (optional) 
     * @param thirdparty_ids (optional) 
     * @param category (optional) 
     * @param sqlfilters (optional) 
     * @param includecount (optional) 
     * @param includeroles (optional) 
     * @return Success
     */
    contactsAll(sortfield?: string | undefined, sortorder?: string | undefined, limit?: number | undefined, page?: number | undefined, thirdparty_ids?: string | undefined, category?: number | undefined, sqlfilters?: string | undefined, includecount?: number | undefined, includeroles?: number | undefined): Promise<ContactDto[]> {
        let url_ = this.baseUrl + "/api/Contacts?";
        if (sortfield === null)
            throw new Error("The parameter 'sortfield' cannot be null.");
        else if (sortfield !== undefined)
            url_ += "sortfield=" + encodeURIComponent("" + sortfield) + "&";
        if (sortorder === null)
            throw new Error("The parameter 'sortorder' cannot be null.");
        else if (sortorder !== undefined)
            url_ += "sortorder=" + encodeURIComponent("" + sortorder) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (thirdparty_ids === null)
            throw new Error("The parameter 'thirdparty_ids' cannot be null.");
        else if (thirdparty_ids !== undefined)
            url_ += "thirdparty_ids=" + encodeURIComponent("" + thirdparty_ids) + "&";
        if (category === null)
            throw new Error("The parameter 'category' cannot be null.");
        else if (category !== undefined)
            url_ += "category=" + encodeURIComponent("" + category) + "&";
        if (sqlfilters === null)
            throw new Error("The parameter 'sqlfilters' cannot be null.");
        else if (sqlfilters !== undefined)
            url_ += "sqlfilters=" + encodeURIComponent("" + sqlfilters) + "&";
        if (includecount === null)
            throw new Error("The parameter 'includecount' cannot be null.");
        else if (includecount !== undefined)
            url_ += "includecount=" + encodeURIComponent("" + includecount) + "&";
        if (includeroles === null)
            throw new Error("The parameter 'includeroles' cannot be null.");
        else if (includeroles !== undefined)
            url_ += "includeroles=" + encodeURIComponent("" + includeroles) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processContactsAll(_response);
        });
    }

    protected processContactsAll(response: Response): Promise<ContactDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ContactDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContactDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    contactsPOST(body: ContactDto | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/Contacts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processContactsPOST(_response);
        });
    }

    protected processContactsPOST(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @return Success
     */
    contactsGET(id: number): Promise<ContactDto> {
        let url_ = this.baseUrl + "/api/Contacts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processContactsGET(_response);
        });
    }

    protected processContactsGET(response: Response): Promise<ContactDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContactDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContactDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    contactsPUT(id: number, body: ContactDto | undefined): Promise<ContactDto> {
        let url_ = this.baseUrl + "/api/Contacts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processContactsPUT(_response);
        });
    }

    protected processContactsPUT(response: Response): Promise<ContactDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContactDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContactDto>(null as any);
    }

    /**
     * @return Success
     */
    contactsDELETE(id: number): Promise<string> {
        let url_ = this.baseUrl + "/api/Contacts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processContactsDELETE(_response);
        });
    }

    protected processContactsDELETE(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @param sortfield (optional) 
     * @param sortorder (optional) 
     * @param limit (optional) 
     * @param page (optional) 
     * @param thirdparty_ids (optional) 
     * @param status (optional) 
     * @param sqlFilters (optional) 
     * @return Success
     */
    invoicesAll(sortfield: string | undefined, sortorder: string | undefined, limit: number | undefined, page: number | undefined, thirdparty_ids: string | undefined, status: string | undefined, sqlFilters: string | undefined): Promise<InvoiceDto[]> {
        let url_ = this.baseUrl + "/api/Invoices?";
        if (sortfield === null)
            throw new Error("The parameter 'sortfield' cannot be null.");
        else if (sortfield !== undefined)
            url_ += "sortfield=" + encodeURIComponent("" + sortfield) + "&";
        if (sortorder === null)
            throw new Error("The parameter 'sortorder' cannot be null.");
        else if (sortorder !== undefined)
            url_ += "sortorder=" + encodeURIComponent("" + sortorder) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (thirdparty_ids === null)
            throw new Error("The parameter 'thirdparty_ids' cannot be null.");
        else if (thirdparty_ids !== undefined)
            url_ += "thirdparty_ids=" + encodeURIComponent("" + thirdparty_ids) + "&";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        if (sqlFilters === null)
            throw new Error("The parameter 'sqlFilters' cannot be null.");
        else if (sqlFilters !== undefined)
            url_ += "sqlFilters=" + encodeURIComponent("" + sqlFilters) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInvoicesAll(_response);
        });
    }

    protected processInvoicesAll(response: Response): Promise<InvoiceDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(InvoiceDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InvoiceDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    invoicesPOST(body: InvoiceDto | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/Invoices";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInvoicesPOST(_response);
        });
    }

    protected processInvoicesPOST(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @return Success
     */
    invoicesGET(id: number): Promise<InvoiceDto> {
        let url_ = this.baseUrl + "/api/Invoices/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInvoicesGET(_response);
        });
    }

    protected processInvoicesGET(response: Response): Promise<InvoiceDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvoiceDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InvoiceDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    invoicesPUT(id: number, body: InvoiceDto | undefined): Promise<InvoiceDto> {
        let url_ = this.baseUrl + "/api/Invoices/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInvoicesPUT(_response);
        });
    }

    protected processInvoicesPUT(response: Response): Promise<InvoiceDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvoiceDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InvoiceDto>(null as any);
    }

    /**
     * @return Success
     */
    invoicesDELETE(id: number): Promise<string> {
        let url_ = this.baseUrl + "/api/Invoices/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInvoicesDELETE(_response);
        });
    }

    protected processInvoicesDELETE(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @param login (optional) 
     * @param password (optional) 
     * @param entity (optional) 
     * @param reset (optional) 
     * @return Success
     */
    login(login: string | undefined, password: string | undefined, entity?: string | undefined, reset?: number | undefined): Promise<LoginResponseDto> {
        let url_ = this.baseUrl + "/api/Login?";
        if (login === null)
            throw new Error("The parameter 'login' cannot be null.");
        else if (login !== undefined)
            url_ += "login=" + encodeURIComponent("" + login) + "&";
        if (password === null)
            throw new Error("The parameter 'password' cannot be null.");
        else if (password !== undefined)
            url_ += "password=" + encodeURIComponent("" + password) + "&";
        if (entity === null)
            throw new Error("The parameter 'entity' cannot be null.");
        else if (entity !== undefined)
            url_ += "entity=" + encodeURIComponent("" + entity) + "&";
        if (reset === null)
            throw new Error("The parameter 'reset' cannot be null.");
        else if (reset !== undefined)
            url_ += "reset=" + encodeURIComponent("" + reset) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogin(_response);
        });
    }

    protected processLogin(response: Response): Promise<LoginResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoginResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LoginResponseDto>(null as any);
    }

    /**
     * @param sortfield (optional) 
     * @param sortorder (optional) 
     * @param limit (optional) 
     * @param page (optional) 
     * @param sqlFilters (optional) 
     * @return Success
     */
    manufacturingOrdersAll(sortfield?: string | undefined, sortorder?: string | undefined, limit?: number | undefined, page?: number | undefined, sqlFilters?: string | undefined): Promise<ManufacturingOrderDto[]> {
        let url_ = this.baseUrl + "/api/ManufacturingOrders?";
        if (sortfield === null)
            throw new Error("The parameter 'sortfield' cannot be null.");
        else if (sortfield !== undefined)
            url_ += "sortfield=" + encodeURIComponent("" + sortfield) + "&";
        if (sortorder === null)
            throw new Error("The parameter 'sortorder' cannot be null.");
        else if (sortorder !== undefined)
            url_ += "sortorder=" + encodeURIComponent("" + sortorder) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (sqlFilters === null)
            throw new Error("The parameter 'sqlFilters' cannot be null.");
        else if (sqlFilters !== undefined)
            url_ += "sqlFilters=" + encodeURIComponent("" + sqlFilters) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processManufacturingOrdersAll(_response);
        });
    }

    protected processManufacturingOrdersAll(response: Response): Promise<ManufacturingOrderDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ManufacturingOrderDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ManufacturingOrderDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    manufacturingOrdersPOST(body: ManufacturingOrderDto | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/ManufacturingOrders";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processManufacturingOrdersPOST(_response);
        });
    }

    protected processManufacturingOrdersPOST(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @return Success
     */
    manufacturingOrdersGET(id: number): Promise<ManufacturingOrderDto> {
        let url_ = this.baseUrl + "/api/ManufacturingOrders/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processManufacturingOrdersGET(_response);
        });
    }

    protected processManufacturingOrdersGET(response: Response): Promise<ManufacturingOrderDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ManufacturingOrderDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ManufacturingOrderDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    manufacturingOrdersPUT(id: number, body: ManufacturingOrderDto | undefined): Promise<ManufacturingOrderDto> {
        let url_ = this.baseUrl + "/api/ManufacturingOrders/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processManufacturingOrdersPUT(_response);
        });
    }

    protected processManufacturingOrdersPUT(response: Response): Promise<ManufacturingOrderDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ManufacturingOrderDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ManufacturingOrderDto>(null as any);
    }

    /**
     * @return Success
     */
    manufacturingOrdersDELETE(id: number): Promise<string> {
        let url_ = this.baseUrl + "/api/ManufacturingOrders/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processManufacturingOrdersDELETE(_response);
        });
    }

    protected processManufacturingOrdersDELETE(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @param sortfield (optional) 
     * @param sortorder (optional) 
     * @param limit (optional) 
     * @param page (optional) 
     * @param typeId (optional) 
     * @param category (optional) 
     * @param sqlFilters (optional) 
     * @return Success
     */
    membersAll(sortfield?: string | undefined, sortorder?: string | undefined, limit?: number | undefined, page?: number | undefined, typeId?: string | undefined, category?: number | undefined, sqlFilters?: string | undefined): Promise<MemberDto[]> {
        let url_ = this.baseUrl + "/api/Members?";
        if (sortfield === null)
            throw new Error("The parameter 'sortfield' cannot be null.");
        else if (sortfield !== undefined)
            url_ += "sortfield=" + encodeURIComponent("" + sortfield) + "&";
        if (sortorder === null)
            throw new Error("The parameter 'sortorder' cannot be null.");
        else if (sortorder !== undefined)
            url_ += "sortorder=" + encodeURIComponent("" + sortorder) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (typeId === null)
            throw new Error("The parameter 'typeId' cannot be null.");
        else if (typeId !== undefined)
            url_ += "typeId=" + encodeURIComponent("" + typeId) + "&";
        if (category === null)
            throw new Error("The parameter 'category' cannot be null.");
        else if (category !== undefined)
            url_ += "category=" + encodeURIComponent("" + category) + "&";
        if (sqlFilters === null)
            throw new Error("The parameter 'sqlFilters' cannot be null.");
        else if (sqlFilters !== undefined)
            url_ += "sqlFilters=" + encodeURIComponent("" + sqlFilters) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMembersAll(_response);
        });
    }

    protected processMembersAll(response: Response): Promise<MemberDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MemberDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MemberDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    membersPOST(body: MemberDto | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/Members";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMembersPOST(_response);
        });
    }

    protected processMembersPOST(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @return Success
     */
    membersGET(id: number): Promise<MemberDto> {
        let url_ = this.baseUrl + "/api/Members/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMembersGET(_response);
        });
    }

    protected processMembersGET(response: Response): Promise<MemberDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MemberDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MemberDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    membersPUT(id: number, body: MemberDto | undefined): Promise<MemberDto> {
        let url_ = this.baseUrl + "/api/Members/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMembersPUT(_response);
        });
    }

    protected processMembersPUT(response: Response): Promise<MemberDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MemberDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MemberDto>(null as any);
    }

    /**
     * @return Success
     */
    membersDELETE(id: number): Promise<string> {
        let url_ = this.baseUrl + "/api/Members/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMembersDELETE(_response);
        });
    }

    protected processMembersDELETE(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @param sortfield (optional) 
     * @param sortorder (optional) 
     * @param limit (optional) 
     * @param page (optional) 
     * @param sqlFilters (optional) 
     * @return Success
     */
    membersTypesAll(sortfield?: string | undefined, sortorder?: string | undefined, limit?: number | undefined, page?: number | undefined, sqlFilters?: string | undefined): Promise<MembersTypeDto[]> {
        let url_ = this.baseUrl + "/api/MembersTypes?";
        if (sortfield === null)
            throw new Error("The parameter 'sortfield' cannot be null.");
        else if (sortfield !== undefined)
            url_ += "sortfield=" + encodeURIComponent("" + sortfield) + "&";
        if (sortorder === null)
            throw new Error("The parameter 'sortorder' cannot be null.");
        else if (sortorder !== undefined)
            url_ += "sortorder=" + encodeURIComponent("" + sortorder) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (sqlFilters === null)
            throw new Error("The parameter 'sqlFilters' cannot be null.");
        else if (sqlFilters !== undefined)
            url_ += "sqlFilters=" + encodeURIComponent("" + sqlFilters) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMembersTypesAll(_response);
        });
    }

    protected processMembersTypesAll(response: Response): Promise<MembersTypeDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MembersTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MembersTypeDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    membersTypesPOST(body: MembersTypeDto | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/MembersTypes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMembersTypesPOST(_response);
        });
    }

    protected processMembersTypesPOST(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @return Success
     */
    membersTypesGET(id: number): Promise<MembersTypeDto> {
        let url_ = this.baseUrl + "/api/MembersTypes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMembersTypesGET(_response);
        });
    }

    protected processMembersTypesGET(response: Response): Promise<MembersTypeDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MembersTypeDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MembersTypeDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    membersTypesPUT(id: number, body: MembersTypeDto | undefined): Promise<MembersTypeDto> {
        let url_ = this.baseUrl + "/api/MembersTypes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMembersTypesPUT(_response);
        });
    }

    protected processMembersTypesPUT(response: Response): Promise<MembersTypeDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MembersTypeDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MembersTypeDto>(null as any);
    }

    /**
     * @return Success
     */
    membersTypesDELETE(id: number): Promise<string> {
        let url_ = this.baseUrl + "/api/MembersTypes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMembersTypesDELETE(_response);
        });
    }

    protected processMembersTypesDELETE(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @param sortfield (optional) 
     * @param sortorder (optional) 
     * @param limit (optional) 
     * @param page (optional) 
     * @param thirdparty_ids (optional) 
     * @param category (optional) 
     * @param sqlFilters (optional) 
     * @return Success
     */
    ordersAll(sortfield?: string | undefined, sortorder?: string | undefined, limit?: number | undefined, page?: number | undefined, thirdparty_ids?: string | undefined, category?: number | undefined, sqlFilters?: string | undefined): Promise<OrderDto[]> {
        let url_ = this.baseUrl + "/api/Orders?";
        if (sortfield === null)
            throw new Error("The parameter 'sortfield' cannot be null.");
        else if (sortfield !== undefined)
            url_ += "sortfield=" + encodeURIComponent("" + sortfield) + "&";
        if (sortorder === null)
            throw new Error("The parameter 'sortorder' cannot be null.");
        else if (sortorder !== undefined)
            url_ += "sortorder=" + encodeURIComponent("" + sortorder) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (thirdparty_ids === null)
            throw new Error("The parameter 'thirdparty_ids' cannot be null.");
        else if (thirdparty_ids !== undefined)
            url_ += "thirdparty_ids=" + encodeURIComponent("" + thirdparty_ids) + "&";
        if (category === null)
            throw new Error("The parameter 'category' cannot be null.");
        else if (category !== undefined)
            url_ += "category=" + encodeURIComponent("" + category) + "&";
        if (sqlFilters === null)
            throw new Error("The parameter 'sqlFilters' cannot be null.");
        else if (sqlFilters !== undefined)
            url_ += "sqlFilters=" + encodeURIComponent("" + sqlFilters) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processOrdersAll(_response);
        });
    }

    protected processOrdersAll(response: Response): Promise<OrderDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OrderDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OrderDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    ordersPOST(body: OrderDto | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/Orders";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processOrdersPOST(_response);
        });
    }

    protected processOrdersPOST(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @return Success
     */
    ordersGET(id: number): Promise<OrderDto> {
        let url_ = this.baseUrl + "/api/Orders/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processOrdersGET(_response);
        });
    }

    protected processOrdersGET(response: Response): Promise<OrderDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OrderDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    ordersPUT(id: number, body: OrderDto | undefined): Promise<OrderDto> {
        let url_ = this.baseUrl + "/api/Orders/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processOrdersPUT(_response);
        });
    }

    protected processOrdersPUT(response: Response): Promise<OrderDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OrderDto>(null as any);
    }

    /**
     * @return Success
     */
    ordersDELETE(id: number): Promise<string> {
        let url_ = this.baseUrl + "/api/Orders/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processOrdersDELETE(_response);
        });
    }

    protected processOrdersDELETE(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @param sortfield (optional) 
     * @param sortorder (optional) 
     * @param limit (optional) 
     * @param page (optional) 
     * @param mode (optional) 
     * @param category (optional) 
     * @param sqlfilters (optional) 
     * @return Success
     */
    productsAll(sortfield?: string | undefined, sortorder?: string | undefined, limit?: number | undefined, page?: number | undefined, mode?: number | undefined, category?: number | undefined, sqlfilters?: string | undefined): Promise<ProductDto[]> {
        let url_ = this.baseUrl + "/api/Products?";
        if (sortfield === null)
            throw new Error("The parameter 'sortfield' cannot be null.");
        else if (sortfield !== undefined)
            url_ += "sortfield=" + encodeURIComponent("" + sortfield) + "&";
        if (sortorder === null)
            throw new Error("The parameter 'sortorder' cannot be null.");
        else if (sortorder !== undefined)
            url_ += "sortorder=" + encodeURIComponent("" + sortorder) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (mode === null)
            throw new Error("The parameter 'mode' cannot be null.");
        else if (mode !== undefined)
            url_ += "mode=" + encodeURIComponent("" + mode) + "&";
        if (category === null)
            throw new Error("The parameter 'category' cannot be null.");
        else if (category !== undefined)
            url_ += "category=" + encodeURIComponent("" + category) + "&";
        if (sqlfilters === null)
            throw new Error("The parameter 'sqlfilters' cannot be null.");
        else if (sqlfilters !== undefined)
            url_ += "sqlfilters=" + encodeURIComponent("" + sqlfilters) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProductsAll(_response);
        });
    }

    protected processProductsAll(response: Response): Promise<ProductDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProductDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    productsPOST(body: ProductDto | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/Products";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProductsPOST(_response);
        });
    }

    protected processProductsPOST(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @return Success
     */
    productsGET(id: number): Promise<ProductDto> {
        let url_ = this.baseUrl + "/api/Products/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProductsGET(_response);
        });
    }

    protected processProductsGET(response: Response): Promise<ProductDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProductDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    productsPUT(id: number, body: ProductDto | undefined): Promise<ProductDto> {
        let url_ = this.baseUrl + "/api/Products/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProductsPUT(_response);
        });
    }

    protected processProductsPUT(response: Response): Promise<ProductDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProductDto>(null as any);
    }

    /**
     * @return Success
     */
    productsDELETE(id: number): Promise<string> {
        let url_ = this.baseUrl + "/api/Products/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProductsDELETE(_response);
        });
    }

    protected processProductsDELETE(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @param sortfield (optional) 
     * @param sortorder (optional) 
     * @param limit (optional) 
     * @param page (optional) 
     * @return Success
     */
    categories(id: number, sortfield: string | undefined, sortorder: string | undefined, limit: number | undefined, page: number | undefined): Promise<CategoryDto[]> {
        let url_ = this.baseUrl + "/api/Products/{id}/categories?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (sortfield === null)
            throw new Error("The parameter 'sortfield' cannot be null.");
        else if (sortfield !== undefined)
            url_ += "sortfield=" + encodeURIComponent("" + sortfield) + "&";
        if (sortorder === null)
            throw new Error("The parameter 'sortorder' cannot be null.");
        else if (sortorder !== undefined)
            url_ += "sortorder=" + encodeURIComponent("" + sortorder) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCategories(_response);
        });
    }

    protected processCategories(response: Response): Promise<CategoryDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CategoryDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CategoryDto[]>(null as any);
    }

    /**
     * @param sortfield (optional) 
     * @param sortorder (optional) 
     * @param limit (optional) 
     * @param page (optional) 
     * @param thirdparty_ids (optional) 
     * @param category (optional) 
     * @param sqlFilters (optional) 
     * @return Success
     */
    projectsAll(sortfield?: string | undefined, sortorder?: string | undefined, limit?: number | undefined, page?: number | undefined, thirdparty_ids?: string | undefined, category?: number | undefined, sqlFilters?: string | undefined): Promise<ProjectDto[]> {
        let url_ = this.baseUrl + "/api/Projects?";
        if (sortfield === null)
            throw new Error("The parameter 'sortfield' cannot be null.");
        else if (sortfield !== undefined)
            url_ += "sortfield=" + encodeURIComponent("" + sortfield) + "&";
        if (sortorder === null)
            throw new Error("The parameter 'sortorder' cannot be null.");
        else if (sortorder !== undefined)
            url_ += "sortorder=" + encodeURIComponent("" + sortorder) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (thirdparty_ids === null)
            throw new Error("The parameter 'thirdparty_ids' cannot be null.");
        else if (thirdparty_ids !== undefined)
            url_ += "thirdparty_ids=" + encodeURIComponent("" + thirdparty_ids) + "&";
        if (category === null)
            throw new Error("The parameter 'category' cannot be null.");
        else if (category !== undefined)
            url_ += "category=" + encodeURIComponent("" + category) + "&";
        if (sqlFilters === null)
            throw new Error("The parameter 'sqlFilters' cannot be null.");
        else if (sqlFilters !== undefined)
            url_ += "sqlFilters=" + encodeURIComponent("" + sqlFilters) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProjectsAll(_response);
        });
    }

    protected processProjectsAll(response: Response): Promise<ProjectDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjectDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProjectDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    projectsPOST(body: ProjectDto | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/Projects";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProjectsPOST(_response);
        });
    }

    protected processProjectsPOST(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @return Success
     */
    projectsGET(id: number): Promise<ProjectDto> {
        let url_ = this.baseUrl + "/api/Projects/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProjectsGET(_response);
        });
    }

    protected processProjectsGET(response: Response): Promise<ProjectDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProjectDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    projectsPUT(id: number, body: ProjectDto | undefined): Promise<ProjectDto> {
        let url_ = this.baseUrl + "/api/Projects/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProjectsPUT(_response);
        });
    }

    protected processProjectsPUT(response: Response): Promise<ProjectDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProjectDto>(null as any);
    }

    /**
     * @return Success
     */
    projectsDELETE(id: number): Promise<string> {
        let url_ = this.baseUrl + "/api/Projects/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProjectsDELETE(_response);
        });
    }

    protected processProjectsDELETE(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @return Success
     */
    tasks(id: number): Promise<TaskDto[]> {
        let url_ = this.baseUrl + "/api/Projects/{id}/tasks";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTasks(_response);
        });
    }

    protected processTasks(response: Response): Promise<TaskDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TaskDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TaskDto[]>(null as any);
    }

    /**
     * @param sortfield (optional) 
     * @param sortorder (optional) 
     * @param limit (optional) 
     * @param page (optional) 
     * @param thirdparty_ids (optional) 
     * @param sqlFilters (optional) 
     * @return Success
     */
    proposalsAll(sortfield: string | undefined, sortorder: string | undefined, limit: number | undefined, page: number | undefined, thirdparty_ids: string | undefined, sqlFilters: string | undefined): Promise<ProposalDto[]> {
        let url_ = this.baseUrl + "/api/Proposals?";
        if (sortfield === null)
            throw new Error("The parameter 'sortfield' cannot be null.");
        else if (sortfield !== undefined)
            url_ += "sortfield=" + encodeURIComponent("" + sortfield) + "&";
        if (sortorder === null)
            throw new Error("The parameter 'sortorder' cannot be null.");
        else if (sortorder !== undefined)
            url_ += "sortorder=" + encodeURIComponent("" + sortorder) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (thirdparty_ids === null)
            throw new Error("The parameter 'thirdparty_ids' cannot be null.");
        else if (thirdparty_ids !== undefined)
            url_ += "thirdparty_ids=" + encodeURIComponent("" + thirdparty_ids) + "&";
        if (sqlFilters === null)
            throw new Error("The parameter 'sqlFilters' cannot be null.");
        else if (sqlFilters !== undefined)
            url_ += "sqlFilters=" + encodeURIComponent("" + sqlFilters) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProposalsAll(_response);
        });
    }

    protected processProposalsAll(response: Response): Promise<ProposalDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProposalDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProposalDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    proposalsPOST(body: ProposalDto | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/Proposals";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProposalsPOST(_response);
        });
    }

    protected processProposalsPOST(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @return Success
     */
    proposalsGET(id: number): Promise<ProposalDto> {
        let url_ = this.baseUrl + "/api/Proposals/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProposalsGET(_response);
        });
    }

    protected processProposalsGET(response: Response): Promise<ProposalDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProposalDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProposalDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    proposalsPUT(id: number, body: ProposalDto | undefined): Promise<ProposalDto> {
        let url_ = this.baseUrl + "/api/Proposals/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProposalsPUT(_response);
        });
    }

    protected processProposalsPUT(response: Response): Promise<ProposalDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProposalDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProposalDto>(null as any);
    }

    /**
     * @return Success
     */
    proposalsDELETE(id: number): Promise<string> {
        let url_ = this.baseUrl + "/api/Proposals/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProposalsDELETE(_response);
        });
    }

    protected processProposalsDELETE(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @param sortfield (optional) 
     * @param sortorder (optional) 
     * @param limit (optional) 
     * @param page (optional) 
     * @param filter (optional) 
     * @param lang (optional) 
     * @param sqlFilters (optional) 
     * @return Success
     */
    countriesAll(sortfield?: string | undefined, sortorder?: string | undefined, limit?: number | undefined, page?: number | undefined, filter?: string | undefined, lang?: string | undefined, sqlFilters?: string | undefined): Promise<CountryDto[]> {
        let url_ = this.baseUrl + "/countries?";
        if (sortfield === null)
            throw new Error("The parameter 'sortfield' cannot be null.");
        else if (sortfield !== undefined)
            url_ += "sortfield=" + encodeURIComponent("" + sortfield) + "&";
        if (sortorder === null)
            throw new Error("The parameter 'sortorder' cannot be null.");
        else if (sortorder !== undefined)
            url_ += "sortorder=" + encodeURIComponent("" + sortorder) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        if (lang === null)
            throw new Error("The parameter 'lang' cannot be null.");
        else if (lang !== undefined)
            url_ += "lang=" + encodeURIComponent("" + lang) + "&";
        if (sqlFilters === null)
            throw new Error("The parameter 'sqlFilters' cannot be null.");
        else if (sqlFilters !== undefined)
            url_ += "sqlFilters=" + encodeURIComponent("" + sqlFilters) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCountriesAll(_response);
        });
    }

    protected processCountriesAll(response: Response): Promise<CountryDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CountryDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CountryDto[]>(null as any);
    }

    /**
     * @param lang (optional) 
     * @return Success
     */
    countries(id: number, lang: string | undefined): Promise<CountryDto> {
        let url_ = this.baseUrl + "/countries/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (lang === null)
            throw new Error("The parameter 'lang' cannot be null.");
        else if (lang !== undefined)
            url_ += "lang=" + encodeURIComponent("" + lang) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCountries(_response);
        });
    }

    protected processCountries(response: Response): Promise<CountryDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CountryDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CountryDto>(null as any);
    }

    /**
     * @param lang (optional) 
     * @return Success
     */
    byCode(code: string, lang: string | undefined): Promise<CountryDto> {
        let url_ = this.baseUrl + "/countries/byCode/{code}?";
        if (code === undefined || code === null)
            throw new Error("The parameter 'code' must be defined.");
        url_ = url_.replace("{code}", encodeURIComponent("" + code));
        if (lang === null)
            throw new Error("The parameter 'lang' cannot be null.");
        else if (lang !== undefined)
            url_ += "lang=" + encodeURIComponent("" + lang) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processByCode(_response);
        });
    }

    protected processByCode(response: Response): Promise<CountryDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CountryDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CountryDto>(null as any);
    }

    /**
     * @param lang (optional) 
     * @return Success
     */
    byISO(iso: string, lang: string | undefined): Promise<CountryDto> {
        let url_ = this.baseUrl + "/countries/byISO/{iso}?";
        if (iso === undefined || iso === null)
            throw new Error("The parameter 'iso' must be defined.");
        url_ = url_.replace("{iso}", encodeURIComponent("" + iso));
        if (lang === null)
            throw new Error("The parameter 'lang' cannot be null.");
        else if (lang !== undefined)
            url_ += "lang=" + encodeURIComponent("" + lang) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processByISO(_response);
        });
    }

    protected processByISO(response: Response): Promise<CountryDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CountryDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CountryDto>(null as any);
    }

    /**
     * @param sortfield (optional) 
     * @param sortorder (optional) 
     * @param limit (optional) 
     * @param page (optional) 
     * @param active (optional) 
     * @param sqlFilters (optional) 
     * @return Success
     */
    currencies(sortfield: string | undefined, sortorder: string | undefined, limit: number | undefined, page: number | undefined, active: number | undefined, sqlFilters: string | undefined): Promise<CurrencyDto[]> {
        let url_ = this.baseUrl + "/currencies?";
        if (sortfield === null)
            throw new Error("The parameter 'sortfield' cannot be null.");
        else if (sortfield !== undefined)
            url_ += "sortfield=" + encodeURIComponent("" + sortfield) + "&";
        if (sortorder === null)
            throw new Error("The parameter 'sortorder' cannot be null.");
        else if (sortorder !== undefined)
            url_ += "sortorder=" + encodeURIComponent("" + sortorder) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (active === null)
            throw new Error("The parameter 'active' cannot be null.");
        else if (active !== undefined)
            url_ += "active=" + encodeURIComponent("" + active) + "&";
        if (sqlFilters === null)
            throw new Error("The parameter 'sqlFilters' cannot be null.");
        else if (sqlFilters !== undefined)
            url_ += "sqlFilters=" + encodeURIComponent("" + sqlFilters) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCurrencies(_response);
        });
    }

    protected processCurrencies(response: Response): Promise<CurrencyDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CurrencyDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CurrencyDto[]>(null as any);
    }

    /**
     * @param sortfield (optional) 
     * @param sortorder (optional) 
     * @param limit (optional) 
     * @param page (optional) 
     * @param active (optional) 
     * @param sqlFilters (optional) 
     * @return Success
     */
    availability(sortfield: string | undefined, sortorder: string | undefined, limit: number | undefined, page: number | undefined, active: number | undefined, sqlFilters: string | undefined): Promise<AvailabilityDto[]> {
        let url_ = this.baseUrl + "/availability?";
        if (sortfield === null)
            throw new Error("The parameter 'sortfield' cannot be null.");
        else if (sortfield !== undefined)
            url_ += "sortfield=" + encodeURIComponent("" + sortfield) + "&";
        if (sortorder === null)
            throw new Error("The parameter 'sortorder' cannot be null.");
        else if (sortorder !== undefined)
            url_ += "sortorder=" + encodeURIComponent("" + sortorder) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (active === null)
            throw new Error("The parameter 'active' cannot be null.");
        else if (active !== undefined)
            url_ += "active=" + encodeURIComponent("" + active) + "&";
        if (sqlFilters === null)
            throw new Error("The parameter 'sqlFilters' cannot be null.");
        else if (sqlFilters !== undefined)
            url_ += "sqlFilters=" + encodeURIComponent("" + sqlFilters) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAvailability(_response);
        });
    }

    protected processAvailability(response: Response): Promise<AvailabilityDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AvailabilityDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AvailabilityDto[]>(null as any);
    }

    /**
     * @param sortfield (optional) 
     * @param sortorder (optional) 
     * @param limit (optional) 
     * @param page (optional) 
     * @param module (optional) 
     * @param active (optional) 
     * @param lang (optional) 
     * @param sqlFilters (optional) 
     * @return Success
     */
    civilities(sortfield: string | undefined, sortorder: string | undefined, limit: number | undefined, page: number | undefined, module: string | undefined, active: number | undefined, lang: string | undefined, sqlFilters: string | undefined): Promise<CivilityDto[]> {
        let url_ = this.baseUrl + "/civilities?";
        if (sortfield === null)
            throw new Error("The parameter 'sortfield' cannot be null.");
        else if (sortfield !== undefined)
            url_ += "sortfield=" + encodeURIComponent("" + sortfield) + "&";
        if (sortorder === null)
            throw new Error("The parameter 'sortorder' cannot be null.");
        else if (sortorder !== undefined)
            url_ += "sortorder=" + encodeURIComponent("" + sortorder) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (module === null)
            throw new Error("The parameter 'module' cannot be null.");
        else if (module !== undefined)
            url_ += "module=" + encodeURIComponent("" + module) + "&";
        if (active === null)
            throw new Error("The parameter 'active' cannot be null.");
        else if (active !== undefined)
            url_ += "active=" + encodeURIComponent("" + active) + "&";
        if (lang === null)
            throw new Error("The parameter 'lang' cannot be null.");
        else if (lang !== undefined)
            url_ += "lang=" + encodeURIComponent("" + lang) + "&";
        if (sqlFilters === null)
            throw new Error("The parameter 'sqlFilters' cannot be null.");
        else if (sqlFilters !== undefined)
            url_ += "sqlFilters=" + encodeURIComponent("" + sqlFilters) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCivilities(_response);
        });
    }

    protected processCivilities(response: Response): Promise<CivilityDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CivilityDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CivilityDto[]>(null as any);
    }

    /**
     * @param sortfield (optional) 
     * @param sortorder (optional) 
     * @param limit (optional) 
     * @param page (optional) 
     * @param module (optional) 
     * @param active (optional) 
     * @param sqlFilters (optional) 
     * @return Success
     */
    incoterms(sortfield: string | undefined, sortorder: string | undefined, limit: number | undefined, page: number | undefined, module: string | undefined, active: number | undefined, sqlFilters: string | undefined): Promise<IncotermDto[]> {
        let url_ = this.baseUrl + "/incoterms?";
        if (sortfield === null)
            throw new Error("The parameter 'sortfield' cannot be null.");
        else if (sortfield !== undefined)
            url_ += "sortfield=" + encodeURIComponent("" + sortfield) + "&";
        if (sortorder === null)
            throw new Error("The parameter 'sortorder' cannot be null.");
        else if (sortorder !== undefined)
            url_ += "sortorder=" + encodeURIComponent("" + sortorder) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (module === null)
            throw new Error("The parameter 'module' cannot be null.");
        else if (module !== undefined)
            url_ += "module=" + encodeURIComponent("" + module) + "&";
        if (active === null)
            throw new Error("The parameter 'active' cannot be null.");
        else if (active !== undefined)
            url_ += "active=" + encodeURIComponent("" + active) + "&";
        if (sqlFilters === null)
            throw new Error("The parameter 'sqlFilters' cannot be null.");
        else if (sqlFilters !== undefined)
            url_ += "sqlFilters=" + encodeURIComponent("" + sqlFilters) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processIncoterms(_response);
        });
    }

    protected processIncoterms(response: Response): Promise<IncotermDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IncotermDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IncotermDto[]>(null as any);
    }

    /**
     * @param sortfield (optional) 
     * @param sortorder (optional) 
     * @param limit (optional) 
     * @param page (optional) 
     * @param country (optional) 
     * @param filter (optional) 
     * @param sqlFilters (optional) 
     * @return Success
     */
    regionsAll(sortfield?: string | undefined, sortorder?: string | undefined, limit?: number | undefined, page?: number | undefined, country?: number | undefined, filter?: string | undefined, sqlFilters?: string | undefined): Promise<RegionDto[]> {
        let url_ = this.baseUrl + "/regions?";
        if (sortfield === null)
            throw new Error("The parameter 'sortfield' cannot be null.");
        else if (sortfield !== undefined)
            url_ += "sortfield=" + encodeURIComponent("" + sortfield) + "&";
        if (sortorder === null)
            throw new Error("The parameter 'sortorder' cannot be null.");
        else if (sortorder !== undefined)
            url_ += "sortorder=" + encodeURIComponent("" + sortorder) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (country === null)
            throw new Error("The parameter 'country' cannot be null.");
        else if (country !== undefined)
            url_ += "country=" + encodeURIComponent("" + country) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        if (sqlFilters === null)
            throw new Error("The parameter 'sqlFilters' cannot be null.");
        else if (sqlFilters !== undefined)
            url_ += "sqlFilters=" + encodeURIComponent("" + sqlFilters) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRegionsAll(_response);
        });
    }

    protected processRegionsAll(response: Response): Promise<RegionDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RegionDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RegionDto[]>(null as any);
    }

    /**
     * @return Success
     */
    regions(id: number): Promise<RegionDto> {
        let url_ = this.baseUrl + "/regions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRegions(_response);
        });
    }

    protected processRegions(response: Response): Promise<RegionDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RegionDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RegionDto>(null as any);
    }

    /**
     * @return Success
     */
    byCode2(code: string): Promise<RegionDto> {
        let url_ = this.baseUrl + "/regions/byCode/{code}";
        if (code === undefined || code === null)
            throw new Error("The parameter 'code' must be defined.");
        url_ = url_.replace("{code}", encodeURIComponent("" + code));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processByCode2(_response);
        });
    }

    protected processByCode2(response: Response): Promise<RegionDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RegionDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RegionDto>(null as any);
    }

    /**
     * @param sortfield (optional) 
     * @param sortorder (optional) 
     * @param limit (optional) 
     * @param page (optional) 
     * @param active (optional) 
     * @param sqlFilters (optional) 
     * @return Success
     */
    socialnetworks(sortfield: string | undefined, sortorder: string | undefined, limit: number | undefined, page: number | undefined, active: number | undefined, sqlFilters: string | undefined): Promise<SocialNetworkDto[]> {
        let url_ = this.baseUrl + "/socialnetworks?";
        if (sortfield === null)
            throw new Error("The parameter 'sortfield' cannot be null.");
        else if (sortfield !== undefined)
            url_ += "sortfield=" + encodeURIComponent("" + sortfield) + "&";
        if (sortorder === null)
            throw new Error("The parameter 'sortorder' cannot be null.");
        else if (sortorder !== undefined)
            url_ += "sortorder=" + encodeURIComponent("" + sortorder) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (active === null)
            throw new Error("The parameter 'active' cannot be null.");
        else if (active !== undefined)
            url_ += "active=" + encodeURIComponent("" + active) + "&";
        if (sqlFilters === null)
            throw new Error("The parameter 'sqlFilters' cannot be null.");
        else if (sqlFilters !== undefined)
            url_ += "sqlFilters=" + encodeURIComponent("" + sqlFilters) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSocialnetworks(_response);
        });
    }

    protected processSocialnetworks(response: Response): Promise<SocialNetworkDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SocialNetworkDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SocialNetworkDto[]>(null as any);
    }

    /**
     * @param sortfield (optional) 
     * @param sortorder (optional) 
     * @param limit (optional) 
     * @param page (optional) 
     * @param active (optional) 
     * @param sqlFilters (optional) 
     * @return Success
     */
    staff(sortfield: string | undefined, sortorder: string | undefined, limit: number | undefined, page: number | undefined, active: number | undefined, sqlFilters: string | undefined): Promise<StaffDto[]> {
        let url_ = this.baseUrl + "/staff?";
        if (sortfield === null)
            throw new Error("The parameter 'sortfield' cannot be null.");
        else if (sortfield !== undefined)
            url_ += "sortfield=" + encodeURIComponent("" + sortfield) + "&";
        if (sortorder === null)
            throw new Error("The parameter 'sortorder' cannot be null.");
        else if (sortorder !== undefined)
            url_ += "sortorder=" + encodeURIComponent("" + sortorder) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (active === null)
            throw new Error("The parameter 'active' cannot be null.");
        else if (active !== undefined)
            url_ += "active=" + encodeURIComponent("" + active) + "&";
        if (sqlFilters === null)
            throw new Error("The parameter 'sqlFilters' cannot be null.");
        else if (sqlFilters !== undefined)
            url_ += "sqlFilters=" + encodeURIComponent("" + sqlFilters) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStaff(_response);
        });
    }

    protected processStaff(response: Response): Promise<StaffDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(StaffDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StaffDto[]>(null as any);
    }

    /**
     * @param sortfield (optional) 
     * @param sortorder (optional) 
     * @param limit (optional) 
     * @param page (optional) 
     * @param country (optional) 
     * @param filter (optional) 
     * @param sqlFilters (optional) 
     * @return Success
     */
    statesAll(sortfield?: string | undefined, sortorder?: string | undefined, limit?: number | undefined, page?: number | undefined, country?: number | undefined, filter?: string | undefined, sqlFilters?: string | undefined): Promise<StateDto[]> {
        let url_ = this.baseUrl + "/states?";
        if (sortfield === null)
            throw new Error("The parameter 'sortfield' cannot be null.");
        else if (sortfield !== undefined)
            url_ += "sortfield=" + encodeURIComponent("" + sortfield) + "&";
        if (sortorder === null)
            throw new Error("The parameter 'sortorder' cannot be null.");
        else if (sortorder !== undefined)
            url_ += "sortorder=" + encodeURIComponent("" + sortorder) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (country === null)
            throw new Error("The parameter 'country' cannot be null.");
        else if (country !== undefined)
            url_ += "country=" + encodeURIComponent("" + country) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        if (sqlFilters === null)
            throw new Error("The parameter 'sqlFilters' cannot be null.");
        else if (sqlFilters !== undefined)
            url_ += "sqlFilters=" + encodeURIComponent("" + sqlFilters) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStatesAll(_response);
        });
    }

    protected processStatesAll(response: Response): Promise<StateDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(StateDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StateDto[]>(null as any);
    }

    /**
     * @return Success
     */
    states(id: number): Promise<StateDto> {
        let url_ = this.baseUrl + "/states/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStates(_response);
        });
    }

    protected processStates(response: Response): Promise<StateDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StateDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StateDto>(null as any);
    }

    /**
     * @param code (optional) 
     * @return Success
     */
    byCode3(code: string | undefined, id: string): Promise<StateDto> {
        let url_ = this.baseUrl + "/states/byCode/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (code === null)
            throw new Error("The parameter 'code' cannot be null.");
        else if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processByCode3(_response);
        });
    }

    protected processByCode3(response: Response): Promise<StateDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StateDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StateDto>(null as any);
    }

    /**
     * @param sortfield (optional) 
     * @param sortorder (optional) 
     * @param limit (optional) 
     * @param page (optional) 
     * @param zipcode (optional) 
     * @param town (optional) 
     * @param active (optional) 
     * @param sqlFilters (optional) 
     * @return Success
     */
    towns(sortfield: string | undefined, sortorder: string | undefined, limit: number | undefined, page: number | undefined, zipcode: string | undefined, town: string | undefined, active: number | undefined, sqlFilters: string | undefined): Promise<TownDto[]> {
        let url_ = this.baseUrl + "/towns?";
        if (sortfield === null)
            throw new Error("The parameter 'sortfield' cannot be null.");
        else if (sortfield !== undefined)
            url_ += "sortfield=" + encodeURIComponent("" + sortfield) + "&";
        if (sortorder === null)
            throw new Error("The parameter 'sortorder' cannot be null.");
        else if (sortorder !== undefined)
            url_ += "sortorder=" + encodeURIComponent("" + sortorder) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (zipcode === null)
            throw new Error("The parameter 'zipcode' cannot be null.");
        else if (zipcode !== undefined)
            url_ += "zipcode=" + encodeURIComponent("" + zipcode) + "&";
        if (town === null)
            throw new Error("The parameter 'town' cannot be null.");
        else if (town !== undefined)
            url_ += "town=" + encodeURIComponent("" + town) + "&";
        if (active === null)
            throw new Error("The parameter 'active' cannot be null.");
        else if (active !== undefined)
            url_ += "active=" + encodeURIComponent("" + active) + "&";
        if (sqlFilters === null)
            throw new Error("The parameter 'sqlFilters' cannot be null.");
        else if (sqlFilters !== undefined)
            url_ += "sqlFilters=" + encodeURIComponent("" + sqlFilters) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTowns(_response);
        });
    }

    protected processTowns(response: Response): Promise<TownDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TownDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TownDto[]>(null as any);
    }

    /**
     * @param sortfield (optional) 
     * @param sortorder (optional) 
     * @param limit (optional) 
     * @param page (optional) 
     * @param active (optional) 
     * @param sqlFilters (optional) 
     * @return Success
     */
    units(sortfield: string | undefined, sortorder: string | undefined, limit: number | undefined, page: number | undefined, active: number | undefined, sqlFilters: string | undefined): Promise<UnitDto[]> {
        let url_ = this.baseUrl + "/units?";
        if (sortfield === null)
            throw new Error("The parameter 'sortfield' cannot be null.");
        else if (sortfield !== undefined)
            url_ += "sortfield=" + encodeURIComponent("" + sortfield) + "&";
        if (sortorder === null)
            throw new Error("The parameter 'sortorder' cannot be null.");
        else if (sortorder !== undefined)
            url_ += "sortorder=" + encodeURIComponent("" + sortorder) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (active === null)
            throw new Error("The parameter 'active' cannot be null.");
        else if (active !== undefined)
            url_ += "active=" + encodeURIComponent("" + active) + "&";
        if (sqlFilters === null)
            throw new Error("The parameter 'sqlFilters' cannot be null.");
        else if (sqlFilters !== undefined)
            url_ += "sqlFilters=" + encodeURIComponent("" + sqlFilters) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUnits(_response);
        });
    }

    protected processUnits(response: Response): Promise<UnitDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UnitDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UnitDto[]>(null as any);
    }

    /**
     * @return Success
     */
    status(): Promise<StatusResponseDto> {
        let url_ = this.baseUrl + "/api/Status";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStatus(_response);
        });
    }

    protected processStatus(response: Response): Promise<StatusResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StatusResponseDto>(null as any);
    }

    /**
     * @param sortfield (optional) 
     * @param sortorder (optional) 
     * @param limit (optional) 
     * @param page (optional) 
     * @param sqlFilters (optional) 
     * @return Success
     */
    tasksAll(sortfield?: string | undefined, sortorder?: string | undefined, limit?: number | undefined, page?: number | undefined, sqlFilters?: string | undefined): Promise<TaskDto[]> {
        let url_ = this.baseUrl + "/api/Tasks?";
        if (sortfield === null)
            throw new Error("The parameter 'sortfield' cannot be null.");
        else if (sortfield !== undefined)
            url_ += "sortfield=" + encodeURIComponent("" + sortfield) + "&";
        if (sortorder === null)
            throw new Error("The parameter 'sortorder' cannot be null.");
        else if (sortorder !== undefined)
            url_ += "sortorder=" + encodeURIComponent("" + sortorder) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (sqlFilters === null)
            throw new Error("The parameter 'sqlFilters' cannot be null.");
        else if (sqlFilters !== undefined)
            url_ += "sqlFilters=" + encodeURIComponent("" + sqlFilters) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTasksAll(_response);
        });
    }

    protected processTasksAll(response: Response): Promise<TaskDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TaskDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TaskDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    tasksPOST(body: TaskDto | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/Tasks";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTasksPOST(_response);
        });
    }

    protected processTasksPOST(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @return Success
     */
    tasksGET(id: number): Promise<TaskDto> {
        let url_ = this.baseUrl + "/api/Tasks/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTasksGET(_response);
        });
    }

    protected processTasksGET(response: Response): Promise<TaskDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TaskDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TaskDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    tasksPUT(id: number, body: TaskDto | undefined): Promise<TaskDto> {
        let url_ = this.baseUrl + "/api/Tasks/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTasksPUT(_response);
        });
    }

    protected processTasksPUT(response: Response): Promise<TaskDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TaskDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TaskDto>(null as any);
    }

    /**
     * @return Success
     */
    tasksDELETE(id: number): Promise<string> {
        let url_ = this.baseUrl + "/api/Tasks/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTasksDELETE(_response);
        });
    }

    protected processTasksDELETE(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @param sortfield (optional) 
     * @param sortorder (optional) 
     * @param limit (optional) 
     * @param page (optional) 
     * @param mode (optional) 
     * @param category (optional) 
     * @param sqlfilters (optional) 
     * @return Success
     */
    thirdpartiesAll(sortfield?: string | undefined, sortorder?: string | undefined, limit?: number | undefined, page?: number | undefined, mode?: number | undefined, category?: number | undefined, sqlfilters?: string | undefined): Promise<ThirdPartyDto[]> {
        let url_ = this.baseUrl + "/api/Thirdparties?";
        if (sortfield === null)
            throw new Error("The parameter 'sortfield' cannot be null.");
        else if (sortfield !== undefined)
            url_ += "sortfield=" + encodeURIComponent("" + sortfield) + "&";
        if (sortorder === null)
            throw new Error("The parameter 'sortorder' cannot be null.");
        else if (sortorder !== undefined)
            url_ += "sortorder=" + encodeURIComponent("" + sortorder) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (mode === null)
            throw new Error("The parameter 'mode' cannot be null.");
        else if (mode !== undefined)
            url_ += "mode=" + encodeURIComponent("" + mode) + "&";
        if (category === null)
            throw new Error("The parameter 'category' cannot be null.");
        else if (category !== undefined)
            url_ += "category=" + encodeURIComponent("" + category) + "&";
        if (sqlfilters === null)
            throw new Error("The parameter 'sqlfilters' cannot be null.");
        else if (sqlfilters !== undefined)
            url_ += "sqlfilters=" + encodeURIComponent("" + sqlfilters) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processThirdpartiesAll(_response);
        });
    }

    protected processThirdpartiesAll(response: Response): Promise<ThirdPartyDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ThirdPartyDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ThirdPartyDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    thirdpartiesPOST(body: ThirdPartyDto | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/Thirdparties";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processThirdpartiesPOST(_response);
        });
    }

    protected processThirdpartiesPOST(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @return Success
     */
    thirdpartiesGET(id: number): Promise<ThirdPartyDto> {
        let url_ = this.baseUrl + "/api/Thirdparties/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processThirdpartiesGET(_response);
        });
    }

    protected processThirdpartiesGET(response: Response): Promise<ThirdPartyDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ThirdPartyDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ThirdPartyDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    thirdpartiesPUT(id: number, body: ThirdPartyDto | undefined): Promise<ThirdPartyDto> {
        let url_ = this.baseUrl + "/api/Thirdparties/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processThirdpartiesPUT(_response);
        });
    }

    protected processThirdpartiesPUT(response: Response): Promise<ThirdPartyDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ThirdPartyDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ThirdPartyDto>(null as any);
    }

    /**
     * @return Success
     */
    thirdpartiesDELETE(id: number): Promise<string> {
        let url_ = this.baseUrl + "/api/Thirdparties/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processThirdpartiesDELETE(_response);
        });
    }

    protected processThirdpartiesDELETE(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @param socid (optional) 
     * @param sortfield (optional) 
     * @param sortorder (optional) 
     * @param limit (optional) 
     * @param page (optional) 
     * @param sqlfilters (optional) 
     * @return Success
     */
    ticketsAll(socid?: number | undefined, sortfield?: string | undefined, sortorder?: string | undefined, limit?: number | undefined, page?: number | undefined, sqlfilters?: string | undefined): Promise<TicketDto[]> {
        let url_ = this.baseUrl + "/api/Tickets?";
        if (socid === null)
            throw new Error("The parameter 'socid' cannot be null.");
        else if (socid !== undefined)
            url_ += "socid=" + encodeURIComponent("" + socid) + "&";
        if (sortfield === null)
            throw new Error("The parameter 'sortfield' cannot be null.");
        else if (sortfield !== undefined)
            url_ += "sortfield=" + encodeURIComponent("" + sortfield) + "&";
        if (sortorder === null)
            throw new Error("The parameter 'sortorder' cannot be null.");
        else if (sortorder !== undefined)
            url_ += "sortorder=" + encodeURIComponent("" + sortorder) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (sqlfilters === null)
            throw new Error("The parameter 'sqlfilters' cannot be null.");
        else if (sqlfilters !== undefined)
            url_ += "sqlfilters=" + encodeURIComponent("" + sqlfilters) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTicketsAll(_response);
        });
    }

    protected processTicketsAll(response: Response): Promise<TicketDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TicketDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TicketDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    ticketsPOST(body: TicketDto | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/Tickets";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTicketsPOST(_response);
        });
    }

    protected processTicketsPOST(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @return Success
     */
    ticketsGET(id: number): Promise<TicketDto> {
        let url_ = this.baseUrl + "/api/Tickets/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTicketsGET(_response);
        });
    }

    protected processTicketsGET(response: Response): Promise<TicketDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TicketDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TicketDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    ticketsPUT(id: number, body: TicketDto | undefined): Promise<TicketDto> {
        let url_ = this.baseUrl + "/api/Tickets/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTicketsPUT(_response);
        });
    }

    protected processTicketsPUT(response: Response): Promise<TicketDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TicketDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TicketDto>(null as any);
    }

    /**
     * @return Success
     */
    ticketsDELETE(id: number): Promise<string> {
        let url_ = this.baseUrl + "/api/Tickets/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTicketsDELETE(_response);
        });
    }

    protected processTicketsDELETE(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @return Success
     */
    byRef(ref: string): Promise<TicketDto> {
        let url_ = this.baseUrl + "/byRef/{ref}";
        if (ref === undefined || ref === null)
            throw new Error("The parameter 'ref' must be defined.");
        url_ = url_.replace("{ref}", encodeURIComponent("" + ref));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processByRef(_response);
        });
    }

    protected processByRef(response: Response): Promise<TicketDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TicketDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TicketDto>(null as any);
    }

    /**
     * @return Success
     */
    byTrackId(track_id: string): Promise<TicketDto> {
        let url_ = this.baseUrl + "/byTrackId/{track_id}";
        if (track_id === undefined || track_id === null)
            throw new Error("The parameter 'track_id' must be defined.");
        url_ = url_.replace("{track_id}", encodeURIComponent("" + track_id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processByTrackId(_response);
        });
    }

    protected processByTrackId(response: Response): Promise<TicketDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TicketDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TicketDto>(null as any);
    }

    /**
     * @param sortfield (optional) 
     * @param sortorder (optional) 
     * @param limit (optional) 
     * @param page (optional) 
     * @param user_ids (optional) 
     * @param category (optional) 
     * @param sqlFilters (optional) 
     * @return Success
     */
    usersAll(sortfield?: string | undefined, sortorder?: string | undefined, limit?: number | undefined, page?: number | undefined, user_ids?: string | undefined, category?: number | undefined, sqlFilters?: string | undefined): Promise<UserDto[]> {
        let url_ = this.baseUrl + "/api/Users?";
        if (sortfield === null)
            throw new Error("The parameter 'sortfield' cannot be null.");
        else if (sortfield !== undefined)
            url_ += "sortfield=" + encodeURIComponent("" + sortfield) + "&";
        if (sortorder === null)
            throw new Error("The parameter 'sortorder' cannot be null.");
        else if (sortorder !== undefined)
            url_ += "sortorder=" + encodeURIComponent("" + sortorder) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (user_ids === null)
            throw new Error("The parameter 'user_ids' cannot be null.");
        else if (user_ids !== undefined)
            url_ += "user_ids=" + encodeURIComponent("" + user_ids) + "&";
        if (category === null)
            throw new Error("The parameter 'category' cannot be null.");
        else if (category !== undefined)
            url_ += "category=" + encodeURIComponent("" + category) + "&";
        if (sqlFilters === null)
            throw new Error("The parameter 'sqlFilters' cannot be null.");
        else if (sqlFilters !== undefined)
            url_ += "sqlFilters=" + encodeURIComponent("" + sqlFilters) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUsersAll(_response);
        });
    }

    protected processUsersAll(response: Response): Promise<UserDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    usersPOST(body: UserDto | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/Users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUsersPOST(_response);
        });
    }

    protected processUsersPOST(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @return Success
     */
    usersGET(id: number): Promise<UserDto> {
        let url_ = this.baseUrl + "/api/Users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUsersGET(_response);
        });
    }

    protected processUsersGET(response: Response): Promise<UserDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserDto>(null as any);
    }

    currentUser(): Promise<UserDto> {
        let url_ = this.baseUrl + "/current";


        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUsersGET(_response);
        });
    }

    protected processCurrentUser(response: Response): Promise<UserDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    usersPUT(id: number, body: UserDto | undefined): Promise<UserDto> {
        let url_ = this.baseUrl + "/api/Users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUsersPUT(_response);
        });
    }

    protected processUsersPUT(response: Response): Promise<UserDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserDto>(null as any);
    }

    /**
     * @return Success
     */
    usersDELETE(id: number): Promise<string> {
        let url_ = this.baseUrl + "/api/Users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUsersDELETE(_response);
        });
    }

    protected processUsersDELETE(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @param sortfield (optional) 
     * @param sortorder (optional) 
     * @param limit (optional) 
     * @param page (optional) 
     * @param category (optional) 
     * @param sqlFilters (optional) 
     * @return Success
     */
    warehousesAll(sortfield?: string | undefined, sortorder?: string | undefined, limit?: number | undefined, page?: number | undefined, category?: number | undefined, sqlFilters?: string | undefined): Promise<WarehouseDto[]> {
        let url_ = this.baseUrl + "/api/Warehouses?";
        if (sortfield === null)
            throw new Error("The parameter 'sortfield' cannot be null.");
        else if (sortfield !== undefined)
            url_ += "sortfield=" + encodeURIComponent("" + sortfield) + "&";
        if (sortorder === null)
            throw new Error("The parameter 'sortorder' cannot be null.");
        else if (sortorder !== undefined)
            url_ += "sortorder=" + encodeURIComponent("" + sortorder) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (category === null)
            throw new Error("The parameter 'category' cannot be null.");
        else if (category !== undefined)
            url_ += "category=" + encodeURIComponent("" + category) + "&";
        if (sqlFilters === null)
            throw new Error("The parameter 'sqlFilters' cannot be null.");
        else if (sqlFilters !== undefined)
            url_ += "sqlFilters=" + encodeURIComponent("" + sqlFilters) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processWarehousesAll(_response);
        });
    }

    protected processWarehousesAll(response: Response): Promise<WarehouseDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WarehouseDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WarehouseDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    warehousesPOST(body: WarehouseDto | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/Warehouses";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processWarehousesPOST(_response);
        });
    }

    protected processWarehousesPOST(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @return Success
     */
    warehousesGET(id: number): Promise<WarehouseDto> {
        let url_ = this.baseUrl + "/api/Warehouses/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processWarehousesGET(_response);
        });
    }

    protected processWarehousesGET(response: Response): Promise<WarehouseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WarehouseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WarehouseDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    warehousesPUT(id: number, body: WarehouseDto | undefined): Promise<WarehouseDto> {
        let url_ = this.baseUrl + "/api/Warehouses/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processWarehousesPUT(_response);
        });
    }

    protected processWarehousesPUT(response: Response): Promise<WarehouseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WarehouseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WarehouseDto>(null as any);
    }

    /**
     * @return Success
     */
    warehousesDELETE(id: number): Promise<string> {
        let url_ = this.baseUrl + "/api/Warehouses/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processWarehousesDELETE(_response);
        });
    }

    protected processWarehousesDELETE(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }
}

export class ContactClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param sortfield (optional) 
     * @param sortorder (optional) 
     * @param limit (optional) 
     * @param page (optional) 
     * @param type (optional) 
     * @param module (optional) 
     * @param active (optional) 
     * @param lang (optional) 
     * @param sqlFilters (optional) 
     * @return Success
     */
    types(sortfield: string | undefined, sortorder: string | undefined, limit: number | undefined, page: number | undefined, type: string | undefined, module: string | undefined, active: number | undefined, lang: string | undefined, sqlFilters: string | undefined): Promise<ContactTypeDto[]> {
        let url_ = this.baseUrl + "/contact_types?";
        if (sortfield === null)
            throw new Error("The parameter 'sortfield' cannot be null.");
        else if (sortfield !== undefined)
            url_ += "sortfield=" + encodeURIComponent("" + sortfield) + "&";
        if (sortorder === null)
            throw new Error("The parameter 'sortorder' cannot be null.");
        else if (sortorder !== undefined)
            url_ += "sortorder=" + encodeURIComponent("" + sortorder) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        if (module === null)
            throw new Error("The parameter 'module' cannot be null.");
        else if (module !== undefined)
            url_ += "module=" + encodeURIComponent("" + module) + "&";
        if (active === null)
            throw new Error("The parameter 'active' cannot be null.");
        else if (active !== undefined)
            url_ += "active=" + encodeURIComponent("" + active) + "&";
        if (lang === null)
            throw new Error("The parameter 'lang' cannot be null.");
        else if (lang !== undefined)
            url_ += "lang=" + encodeURIComponent("" + lang) + "&";
        if (sqlFilters === null)
            throw new Error("The parameter 'sqlFilters' cannot be null.");
        else if (sqlFilters !== undefined)
            url_ += "sqlFilters=" + encodeURIComponent("" + sqlFilters) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTypes(_response);
        });
    }

    protected processTypes(response: Response): Promise<ContactTypeDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ContactTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContactTypeDto[]>(null as any);
    }
}

export class EventClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param sortfield (optional) 
     * @param sortorder (optional) 
     * @param limit (optional) 
     * @param page (optional) 
     * @param type (optional) 
     * @param module (optional) 
     * @param active (optional) 
     * @param sqlFilters (optional) 
     * @return Success
     */
    types(sortfield: string | undefined, sortorder: string | undefined, limit: number | undefined, page: number | undefined, type: string | undefined, module: string | undefined, active: number | undefined, sqlFilters: string | undefined): Promise<EventTypeDto[]> {
        let url_ = this.baseUrl + "/event_types?";
        if (sortfield === null)
            throw new Error("The parameter 'sortfield' cannot be null.");
        else if (sortfield !== undefined)
            url_ += "sortfield=" + encodeURIComponent("" + sortfield) + "&";
        if (sortorder === null)
            throw new Error("The parameter 'sortorder' cannot be null.");
        else if (sortorder !== undefined)
            url_ += "sortorder=" + encodeURIComponent("" + sortorder) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        if (module === null)
            throw new Error("The parameter 'module' cannot be null.");
        else if (module !== undefined)
            url_ += "module=" + encodeURIComponent("" + module) + "&";
        if (active === null)
            throw new Error("The parameter 'active' cannot be null.");
        else if (active !== undefined)
            url_ += "active=" + encodeURIComponent("" + active) + "&";
        if (sqlFilters === null)
            throw new Error("The parameter 'sqlFilters' cannot be null.");
        else if (sqlFilters !== undefined)
            url_ += "sqlFilters=" + encodeURIComponent("" + sqlFilters) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTypes(_response);
        });
    }

    protected processTypes(response: Response): Promise<EventTypeDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EventTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EventTypeDto[]>(null as any);
    }
}

export class ExpensereportClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param sortfield (optional) 
     * @param sortorder (optional) 
     * @param limit (optional) 
     * @param page (optional) 
     * @param module (optional) 
     * @param active (optional) 
     * @param sqlFilters (optional) 
     * @return Success
     */
    types(sortfield: string | undefined, sortorder: string | undefined, limit: number | undefined, page: number | undefined, module: string | undefined, active: number | undefined, sqlFilters: string | undefined): Promise<ExpenseReportTypeDto[]> {
        let url_ = this.baseUrl + "/expensereport_types?";
        if (sortfield === null)
            throw new Error("The parameter 'sortfield' cannot be null.");
        else if (sortfield !== undefined)
            url_ += "sortfield=" + encodeURIComponent("" + sortfield) + "&";
        if (sortorder === null)
            throw new Error("The parameter 'sortorder' cannot be null.");
        else if (sortorder !== undefined)
            url_ += "sortorder=" + encodeURIComponent("" + sortorder) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (module === null)
            throw new Error("The parameter 'module' cannot be null.");
        else if (module !== undefined)
            url_ += "module=" + encodeURIComponent("" + module) + "&";
        if (active === null)
            throw new Error("The parameter 'active' cannot be null.");
        else if (active !== undefined)
            url_ += "active=" + encodeURIComponent("" + active) + "&";
        if (sqlFilters === null)
            throw new Error("The parameter 'sqlFilters' cannot be null.");
        else if (sqlFilters !== undefined)
            url_ += "sqlFilters=" + encodeURIComponent("" + sqlFilters) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTypes(_response);
        });
    }

    protected processTypes(response: Response): Promise<ExpenseReportTypeDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ExpenseReportTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ExpenseReportTypeDto[]>(null as any);
    }
}

export class LegalClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param sortfield (optional) 
     * @param sortorder (optional) 
     * @param limit (optional) 
     * @param page (optional) 
     * @param country (optional) 
     * @param active (optional) 
     * @param sqlFilters (optional) 
     * @return Success
     */
    form(sortfield: string | undefined, sortorder: string | undefined, limit: number | undefined, page: number | undefined, country: number | undefined, active: number | undefined, sqlFilters: string | undefined): Promise<LegalFormDto[]> {
        let url_ = this.baseUrl + "/legal_form?";
        if (sortfield === null)
            throw new Error("The parameter 'sortfield' cannot be null.");
        else if (sortfield !== undefined)
            url_ += "sortfield=" + encodeURIComponent("" + sortfield) + "&";
        if (sortorder === null)
            throw new Error("The parameter 'sortorder' cannot be null.");
        else if (sortorder !== undefined)
            url_ += "sortorder=" + encodeURIComponent("" + sortorder) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (country === null)
            throw new Error("The parameter 'country' cannot be null.");
        else if (country !== undefined)
            url_ += "country=" + encodeURIComponent("" + country) + "&";
        if (active === null)
            throw new Error("The parameter 'active' cannot be null.");
        else if (active !== undefined)
            url_ += "active=" + encodeURIComponent("" + active) + "&";
        if (sqlFilters === null)
            throw new Error("The parameter 'sqlFilters' cannot be null.");
        else if (sqlFilters !== undefined)
            url_ += "sqlFilters=" + encodeURIComponent("" + sqlFilters) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processForm(_response);
        });
    }

    protected processForm(response: Response): Promise<LegalFormDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LegalFormDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LegalFormDto[]>(null as any);
    }
}

export class OrderingClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param sortfield (optional) 
     * @param sortorder (optional) 
     * @param limit (optional) 
     * @param page (optional) 
     * @param active (optional) 
     * @param sqlFilters (optional) 
     * @return Success
     */
    methods(sortfield: string | undefined, sortorder: string | undefined, limit: number | undefined, page: number | undefined, active: number | undefined, sqlFilters: string | undefined): Promise<OrderingMethodDto[]> {
        let url_ = this.baseUrl + "/ordering_methods?";
        if (sortfield === null)
            throw new Error("The parameter 'sortfield' cannot be null.");
        else if (sortfield !== undefined)
            url_ += "sortfield=" + encodeURIComponent("" + sortfield) + "&";
        if (sortorder === null)
            throw new Error("The parameter 'sortorder' cannot be null.");
        else if (sortorder !== undefined)
            url_ += "sortorder=" + encodeURIComponent("" + sortorder) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (active === null)
            throw new Error("The parameter 'active' cannot be null.");
        else if (active !== undefined)
            url_ += "active=" + encodeURIComponent("" + active) + "&";
        if (sqlFilters === null)
            throw new Error("The parameter 'sqlFilters' cannot be null.");
        else if (sqlFilters !== undefined)
            url_ += "sqlFilters=" + encodeURIComponent("" + sqlFilters) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMethods(_response);
        });
    }

    protected processMethods(response: Response): Promise<OrderingMethodDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OrderingMethodDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OrderingMethodDto[]>(null as any);
    }

    /**
     * @param sortfield (optional) 
     * @param sortorder (optional) 
     * @param limit (optional) 
     * @param page (optional) 
     * @param active (optional) 
     * @param sqlFilters (optional) 
     * @return Success
     */
    origins(sortfield: string | undefined, sortorder: string | undefined, limit: number | undefined, page: number | undefined, active: number | undefined, sqlFilters: string | undefined): Promise<OrderingOriginDto[]> {
        let url_ = this.baseUrl + "/ordering_origins?";
        if (sortfield === null)
            throw new Error("The parameter 'sortfield' cannot be null.");
        else if (sortfield !== undefined)
            url_ += "sortfield=" + encodeURIComponent("" + sortfield) + "&";
        if (sortorder === null)
            throw new Error("The parameter 'sortorder' cannot be null.");
        else if (sortorder !== undefined)
            url_ += "sortorder=" + encodeURIComponent("" + sortorder) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (active === null)
            throw new Error("The parameter 'active' cannot be null.");
        else if (active !== undefined)
            url_ += "active=" + encodeURIComponent("" + active) + "&";
        if (sqlFilters === null)
            throw new Error("The parameter 'sqlFilters' cannot be null.");
        else if (sqlFilters !== undefined)
            url_ += "sqlFilters=" + encodeURIComponent("" + sqlFilters) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processOrigins(_response);
        });
    }

    protected processOrigins(response: Response): Promise<OrderingOriginDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OrderingOriginDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OrderingOriginDto[]>(null as any);
    }
}

export class PaymentClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param sortfield (optional) 
     * @param sortorder (optional) 
     * @param limit (optional) 
     * @param page (optional) 
     * @param active (optional) 
     * @param sqlFilters (optional) 
     * @return Success
     */
    terms(sortfield: string | undefined, sortorder: string | undefined, limit: number | undefined, page: number | undefined, active: number | undefined, sqlFilters: string | undefined): Promise<PaymentTermsDto[]> {
        let url_ = this.baseUrl + "/payment_terms?";
        if (sortfield === null)
            throw new Error("The parameter 'sortfield' cannot be null.");
        else if (sortfield !== undefined)
            url_ += "sortfield=" + encodeURIComponent("" + sortfield) + "&";
        if (sortorder === null)
            throw new Error("The parameter 'sortorder' cannot be null.");
        else if (sortorder !== undefined)
            url_ += "sortorder=" + encodeURIComponent("" + sortorder) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (active === null)
            throw new Error("The parameter 'active' cannot be null.");
        else if (active !== undefined)
            url_ += "active=" + encodeURIComponent("" + active) + "&";
        if (sqlFilters === null)
            throw new Error("The parameter 'sqlFilters' cannot be null.");
        else if (sqlFilters !== undefined)
            url_ += "sqlFilters=" + encodeURIComponent("" + sqlFilters) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTerms(_response);
        });
    }

    protected processTerms(response: Response): Promise<PaymentTermsDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PaymentTermsDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaymentTermsDto[]>(null as any);
    }

    /**
     * @param sortfield (optional) 
     * @param sortorder (optional) 
     * @param limit (optional) 
     * @param page (optional) 
     * @param active (optional) 
     * @param sqlFilters (optional) 
     * @return Success
     */
    types(sortfield: string | undefined, sortorder: string | undefined, limit: number | undefined, page: number | undefined, active: number | undefined, sqlFilters: string | undefined): Promise<PaymentTypeDto[]> {
        let url_ = this.baseUrl + "/payment_types?";
        if (sortfield === null)
            throw new Error("The parameter 'sortfield' cannot be null.");
        else if (sortfield !== undefined)
            url_ += "sortfield=" + encodeURIComponent("" + sortfield) + "&";
        if (sortorder === null)
            throw new Error("The parameter 'sortorder' cannot be null.");
        else if (sortorder !== undefined)
            url_ += "sortorder=" + encodeURIComponent("" + sortorder) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (active === null)
            throw new Error("The parameter 'active' cannot be null.");
        else if (active !== undefined)
            url_ += "active=" + encodeURIComponent("" + active) + "&";
        if (sqlFilters === null)
            throw new Error("The parameter 'sqlFilters' cannot be null.");
        else if (sqlFilters !== undefined)
            url_ += "sqlFilters=" + encodeURIComponent("" + sqlFilters) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTypes(_response);
        });
    }

    protected processTypes(response: Response): Promise<PaymentTypeDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PaymentTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaymentTypeDto[]>(null as any);
    }
}

export class ShippingClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param limit (optional) 
     * @param page (optional) 
     * @param active (optional) 
     * @param lang (optional) 
     * @param sqlFilters (optional) 
     * @return Success
     */
    methods(limit: number | undefined, page: number | undefined, active: number | undefined, lang: string | undefined, sqlFilters: string | undefined): Promise<ShippingMethodDto[]> {
        let url_ = this.baseUrl + "/shipping_methods?";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (active === null)
            throw new Error("The parameter 'active' cannot be null.");
        else if (active !== undefined)
            url_ += "active=" + encodeURIComponent("" + active) + "&";
        if (lang === null)
            throw new Error("The parameter 'lang' cannot be null.");
        else if (lang !== undefined)
            url_ += "lang=" + encodeURIComponent("" + lang) + "&";
        if (sqlFilters === null)
            throw new Error("The parameter 'sqlFilters' cannot be null.");
        else if (sqlFilters !== undefined)
            url_ += "sqlFilters=" + encodeURIComponent("" + sqlFilters) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMethods(_response);
        });
    }

    protected processMethods(response: Response): Promise<ShippingMethodDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ShippingMethodDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ShippingMethodDto[]>(null as any);
    }
}

export class TicketClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param sortfield (optional) 
     * @param sortorder (optional) 
     * @param limit (optional) 
     * @param page (optional) 
     * @param active (optional) 
     * @param lang (optional) 
     * @param sqlFilters (optional) 
     * @return Success
     */
    categories(sortfield: string | undefined, sortorder: string | undefined, limit: number | undefined, page: number | undefined, active: number | undefined, lang: string | undefined, sqlFilters: string | undefined): Promise<TicketCategoryDto[]> {
        let url_ = this.baseUrl + "/ticket_categories?";
        if (sortfield === null)
            throw new Error("The parameter 'sortfield' cannot be null.");
        else if (sortfield !== undefined)
            url_ += "sortfield=" + encodeURIComponent("" + sortfield) + "&";
        if (sortorder === null)
            throw new Error("The parameter 'sortorder' cannot be null.");
        else if (sortorder !== undefined)
            url_ += "sortorder=" + encodeURIComponent("" + sortorder) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (active === null)
            throw new Error("The parameter 'active' cannot be null.");
        else if (active !== undefined)
            url_ += "active=" + encodeURIComponent("" + active) + "&";
        if (lang === null)
            throw new Error("The parameter 'lang' cannot be null.");
        else if (lang !== undefined)
            url_ += "lang=" + encodeURIComponent("" + lang) + "&";
        if (sqlFilters === null)
            throw new Error("The parameter 'sqlFilters' cannot be null.");
        else if (sqlFilters !== undefined)
            url_ += "sqlFilters=" + encodeURIComponent("" + sqlFilters) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCategories(_response);
        });
    }

    protected processCategories(response: Response): Promise<TicketCategoryDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TicketCategoryDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TicketCategoryDto[]>(null as any);
    }

    /**
     * @param sortfield (optional) 
     * @param sortorder (optional) 
     * @param limit (optional) 
     * @param page (optional) 
     * @param active (optional) 
     * @param lang (optional) 
     * @param sqlFilters (optional) 
     * @return Success
     */
    severities(sortfield: string | undefined, sortorder: string | undefined, limit: number | undefined, page: number | undefined, active: number | undefined, lang: string | undefined, sqlFilters: string | undefined): Promise<TicketSeveritiesDto[]> {
        let url_ = this.baseUrl + "/ticket_severities?";
        if (sortfield === null)
            throw new Error("The parameter 'sortfield' cannot be null.");
        else if (sortfield !== undefined)
            url_ += "sortfield=" + encodeURIComponent("" + sortfield) + "&";
        if (sortorder === null)
            throw new Error("The parameter 'sortorder' cannot be null.");
        else if (sortorder !== undefined)
            url_ += "sortorder=" + encodeURIComponent("" + sortorder) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (active === null)
            throw new Error("The parameter 'active' cannot be null.");
        else if (active !== undefined)
            url_ += "active=" + encodeURIComponent("" + active) + "&";
        if (lang === null)
            throw new Error("The parameter 'lang' cannot be null.");
        else if (lang !== undefined)
            url_ += "lang=" + encodeURIComponent("" + lang) + "&";
        if (sqlFilters === null)
            throw new Error("The parameter 'sqlFilters' cannot be null.");
        else if (sqlFilters !== undefined)
            url_ += "sqlFilters=" + encodeURIComponent("" + sqlFilters) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSeverities(_response);
        });
    }

    protected processSeverities(response: Response): Promise<TicketSeveritiesDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TicketSeveritiesDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TicketSeveritiesDto[]>(null as any);
    }

    /**
     * @param sortfield (optional) 
     * @param sortorder (optional) 
     * @param limit (optional) 
     * @param page (optional) 
     * @param active (optional) 
     * @param lang (optional) 
     * @param sqlFilters (optional) 
     * @return Success
     */
    types(sortfield: string | undefined, sortorder: string | undefined, limit: number | undefined, page: number | undefined, active: number | undefined, lang: string | undefined, sqlFilters: string | undefined): Promise<TicketTypeDto[]> {
        let url_ = this.baseUrl + "/ticket_types?";
        if (sortfield === null)
            throw new Error("The parameter 'sortfield' cannot be null.");
        else if (sortfield !== undefined)
            url_ += "sortfield=" + encodeURIComponent("" + sortfield) + "&";
        if (sortorder === null)
            throw new Error("The parameter 'sortorder' cannot be null.");
        else if (sortorder !== undefined)
            url_ += "sortorder=" + encodeURIComponent("" + sortorder) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (active === null)
            throw new Error("The parameter 'active' cannot be null.");
        else if (active !== undefined)
            url_ += "active=" + encodeURIComponent("" + active) + "&";
        if (lang === null)
            throw new Error("The parameter 'lang' cannot be null.");
        else if (lang !== undefined)
            url_ += "lang=" + encodeURIComponent("" + lang) + "&";
        if (sqlFilters === null)
            throw new Error("The parameter 'sqlFilters' cannot be null.");
        else if (sqlFilters !== undefined)
            url_ += "sqlFilters=" + encodeURIComponent("" + sqlFilters) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTypes(_response);
        });
    }

    protected processTypes(response: Response): Promise<TicketTypeDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TicketTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TicketTypeDto[]>(null as any);
    }
}

export class AgendaEventDto implements IAgendaEventDto {
    module?: string | undefined;
    id?: string | undefined;
    entity?: string | undefined;
    fk_project?: string | undefined;
    ref?: string | undefined;
    status?: string | undefined;
    shipping_method?: string | undefined;
    note_public?: string | undefined;
    note_private?: string | undefined;
    date_creation?: number | undefined;
    date_validation?: number | undefined;
    date_modification?: number | undefined;
    date_update?: number | undefined;
    date_cloture?: number | undefined;
    specimen?: number | undefined;
    labelStatus?: string | undefined;
    type_id?: string | undefined;
    type?: string | undefined;
    type_code?: string | undefined;
    type_label?: string | undefined;
    type_color?: string | undefined;
    code?: string | undefined;
    label?: string | undefined;
    datec?: number | undefined;
    datem?: number | undefined;
    authorid?: string | undefined;
    usermodid?: string | undefined;
    datep?: number | undefined;
    datef?: number | undefined;
    date_start_in_calendar?: number | undefined;
    date_end_in_calendar?: number | undefined;
    datep2?: number | undefined;
    durationp?: number | undefined;
    fulldayevent?: string | undefined;
    percentage?: string | undefined;
    location?: string | undefined;
    transparency?: string | undefined;
    priority?: string | undefined;
    userownerid?: string | undefined;
    userdoneid?: string | undefined;
    socid?: string | undefined;
    elementid?: string | undefined;
    elementtype?: string | undefined;
    event_paid?: string | undefined;

    constructor(data?: IAgendaEventDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.module = _data["module"];
            this.id = _data["id"];
            this.entity = _data["entity"];
            this.fk_project = _data["fk_project"];
            this.ref = _data["ref"];
            this.status = _data["status"];
            this.shipping_method = _data["shipping_method"];
            this.note_public = _data["note_public"];
            this.note_private = _data["note_private"];
            this.date_creation = _data["date_creation"];
            this.date_validation = _data["date_validation"];
            this.date_modification = _data["date_modification"];
            this.date_update = _data["date_update"];
            this.date_cloture = _data["date_cloture"];
            this.specimen = _data["specimen"];
            this.labelStatus = _data["labelStatus"];
            this.type_id = _data["type_id"];
            this.type = _data["type"];
            this.type_code = _data["type_code"];
            this.type_label = _data["type_label"];
            this.type_color = _data["type_color"];
            this.code = _data["code"];
            this.label = _data["label"];
            this.datec = _data["datec"];
            this.datem = _data["datem"];
            this.authorid = _data["authorid"];
            this.usermodid = _data["usermodid"];
            this.datep = _data["datep"];
            this.datef = _data["datef"];
            this.date_start_in_calendar = _data["date_start_in_calendar"];
            this.date_end_in_calendar = _data["date_end_in_calendar"];
            this.datep2 = _data["datep2"];
            this.durationp = _data["durationp"];
            this.fulldayevent = _data["fulldayevent"];
            this.percentage = _data["percentage"];
            this.location = _data["location"];
            this.transparency = _data["transparency"];
            this.priority = _data["priority"];
            this.userownerid = _data["userownerid"];
            this.userdoneid = _data["userdoneid"];
            this.socid = _data["socid"];
            this.elementid = _data["elementid"];
            this.elementtype = _data["elementtype"];
            this.event_paid = _data["event_paid"];
        }
    }

    static fromJS(data: any): AgendaEventDto {
        data = typeof data === 'object' ? data : {};
        let result = new AgendaEventDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["module"] = this.module;
        data["id"] = this.id;
        data["entity"] = this.entity;
        data["fk_project"] = this.fk_project;
        data["ref"] = this.ref;
        data["status"] = this.status;
        data["shipping_method"] = this.shipping_method;
        data["note_public"] = this.note_public;
        data["note_private"] = this.note_private;
        data["date_creation"] = this.date_creation;
        data["date_validation"] = this.date_validation;
        data["date_modification"] = this.date_modification;
        data["date_update"] = this.date_update;
        data["date_cloture"] = this.date_cloture;
        data["specimen"] = this.specimen;
        data["labelStatus"] = this.labelStatus;
        data["type_id"] = this.type_id;
        data["type"] = this.type;
        data["type_code"] = this.type_code;
        data["type_label"] = this.type_label;
        data["type_color"] = this.type_color;
        data["code"] = this.code;
        data["label"] = this.label;
        data["datec"] = this.datec;
        data["datem"] = this.datem;
        data["authorid"] = this.authorid;
        data["usermodid"] = this.usermodid;
        data["datep"] = this.datep;
        data["datef"] = this.datef;
        data["date_start_in_calendar"] = this.date_start_in_calendar;
        data["date_end_in_calendar"] = this.date_end_in_calendar;
        data["datep2"] = this.datep2;
        data["durationp"] = this.durationp;
        data["fulldayevent"] = this.fulldayevent;
        data["percentage"] = this.percentage;
        data["location"] = this.location;
        data["transparency"] = this.transparency;
        data["priority"] = this.priority;
        data["userownerid"] = this.userownerid;
        data["userdoneid"] = this.userdoneid;
        data["socid"] = this.socid;
        data["elementid"] = this.elementid;
        data["elementtype"] = this.elementtype;
        data["event_paid"] = this.event_paid;
        return data;
    }
}

export interface IAgendaEventDto {
    module?: string | undefined;
    id?: string | undefined;
    entity?: string | undefined;
    fk_project?: string | undefined;
    ref?: string | undefined;
    status?: string | undefined;
    shipping_method?: string | undefined;
    note_public?: string | undefined;
    note_private?: string | undefined;
    date_creation?: number | undefined;
    date_validation?: number | undefined;
    date_modification?: number | undefined;
    date_update?: number | undefined;
    date_cloture?: number | undefined;
    specimen?: number | undefined;
    labelStatus?: string | undefined;
    type_id?: string | undefined;
    type?: string | undefined;
    type_code?: string | undefined;
    type_label?: string | undefined;
    type_color?: string | undefined;
    code?: string | undefined;
    label?: string | undefined;
    datec?: number | undefined;
    datem?: number | undefined;
    authorid?: string | undefined;
    usermodid?: string | undefined;
    datep?: number | undefined;
    datef?: number | undefined;
    date_start_in_calendar?: number | undefined;
    date_end_in_calendar?: number | undefined;
    datep2?: number | undefined;
    durationp?: number | undefined;
    fulldayevent?: string | undefined;
    percentage?: string | undefined;
    location?: string | undefined;
    transparency?: string | undefined;
    priority?: string | undefined;
    userownerid?: string | undefined;
    userdoneid?: string | undefined;
    socid?: string | undefined;
    elementid?: string | undefined;
    elementtype?: string | undefined;
    event_paid?: string | undefined;
}

export class AvailabilityDto implements IAvailabilityDto {
    rowid?: number;
    code?: string | undefined;
    label?: string | undefined;

    constructor(data?: IAvailabilityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rowid = _data["rowid"];
            this.code = _data["code"];
            this.label = _data["label"];
        }
    }

    static fromJS(data: any): AvailabilityDto {
        data = typeof data === 'object' ? data : {};
        let result = new AvailabilityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rowid"] = this.rowid;
        data["code"] = this.code;
        data["label"] = this.label;
        return data;
    }
}

export interface IAvailabilityDto {
    rowid?: number;
    code?: string | undefined;
    label?: string | undefined;
}

export class BillOfMaterialDto implements IBillOfMaterialDto {
    module?: string | undefined;
    id?: number;
    ref?: string | undefined;
    status?: number | undefined;
    specimen?: number | undefined;
    label?: string | undefined;
    bomtype?: number | undefined;
    description?: string | undefined;
    tms?: number | undefined;
    fk_warehouse?: number | undefined;
    fk_product?: number | undefined;
    qty?: number | undefined;
    duration?: string | undefined;
    total_cost?: number | undefined;
    unit_cost?: number | undefined;

    constructor(data?: IBillOfMaterialDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.module = _data["module"];
            this.id = _data["id"];
            this.ref = _data["ref"];
            this.status = _data["status"];
            this.specimen = _data["specimen"];
            this.label = _data["label"];
            this.bomtype = _data["bomtype"];
            this.description = _data["description"];
            this.tms = _data["tms"];
            this.fk_warehouse = _data["fk_warehouse"];
            this.fk_product = _data["fk_product"];
            this.qty = _data["qty"];
            this.duration = _data["duration"];
            this.total_cost = _data["total_cost"];
            this.unit_cost = _data["unit_cost"];
        }
    }

    static fromJS(data: any): BillOfMaterialDto {
        data = typeof data === 'object' ? data : {};
        let result = new BillOfMaterialDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["module"] = this.module;
        data["id"] = this.id;
        data["ref"] = this.ref;
        data["status"] = this.status;
        data["specimen"] = this.specimen;
        data["label"] = this.label;
        data["bomtype"] = this.bomtype;
        data["description"] = this.description;
        data["tms"] = this.tms;
        data["fk_warehouse"] = this.fk_warehouse;
        data["fk_product"] = this.fk_product;
        data["qty"] = this.qty;
        data["duration"] = this.duration;
        data["total_cost"] = this.total_cost;
        data["unit_cost"] = this.unit_cost;
        return data;
    }
}

export interface IBillOfMaterialDto {
    module?: string | undefined;
    id?: number;
    ref?: string | undefined;
    status?: number | undefined;
    specimen?: number | undefined;
    label?: string | undefined;
    bomtype?: number | undefined;
    description?: string | undefined;
    tms?: number | undefined;
    fk_warehouse?: number | undefined;
    fk_product?: number | undefined;
    qty?: number | undefined;
    duration?: string | undefined;
    total_cost?: number | undefined;
    unit_cost?: number | undefined;
}

export class CategoryDto implements ICategoryDto {
    id?: number | undefined;
    ref?: string | undefined;
    fk_parent?: number | undefined;
    label?: string | undefined;
    description?: string | undefined;
    color?: string | undefined;
    position?: number | undefined;
    visible?: number | undefined;
    socid?: number | undefined;
    type?: string | undefined;

    constructor(data?: ICategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.ref = _data["ref"];
            this.fk_parent = _data["fk_parent"];
            this.label = _data["label"];
            this.description = _data["description"];
            this.color = _data["color"];
            this.position = _data["position"];
            this.visible = _data["visible"];
            this.socid = _data["socid"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): CategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["ref"] = this.ref;
        data["fk_parent"] = this.fk_parent;
        data["label"] = this.label;
        data["description"] = this.description;
        data["color"] = this.color;
        data["position"] = this.position;
        data["visible"] = this.visible;
        data["socid"] = this.socid;
        data["type"] = this.type;
        return data;
    }
}

export interface ICategoryDto {
    id?: number | undefined;
    ref?: string | undefined;
    fk_parent?: number | undefined;
    label?: string | undefined;
    description?: string | undefined;
    color?: string | undefined;
    position?: number | undefined;
    visible?: number | undefined;
    socid?: number | undefined;
    type?: string | undefined;
}

export class CivilityDto implements ICivilityDto {
    rowid?: number;
    code?: string | undefined;
    label?: string | undefined;
    module?: string | undefined;

    constructor(data?: ICivilityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rowid = _data["rowid"];
            this.code = _data["code"];
            this.label = _data["label"];
            this.module = _data["module"];
        }
    }

    static fromJS(data: any): CivilityDto {
        data = typeof data === 'object' ? data : {};
        let result = new CivilityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rowid"] = this.rowid;
        data["code"] = this.code;
        data["label"] = this.label;
        data["module"] = this.module;
        return data;
    }
}

export interface ICivilityDto {
    rowid?: number;
    code?: string | undefined;
    label?: string | undefined;
    module?: string | undefined;
}

export class ContactDto implements IContactDto {
    module?: string | undefined;
    id?: number | undefined;
    entity?: string | undefined;
    socid?: string | undefined;
    lastname?: string | undefined;
    firstname?: string | undefined;
    poste?: string | undefined;
    civility_code?: string | undefined;
    fk_soc?: string | undefined;
    socname?: string | undefined;
    address?: string | undefined;
    zip?: string | undefined;
    town?: string | undefined;
    country_id?: number | undefined;
    country_code?: string | undefined;
    state_id?: number | undefined;
    email?: string | undefined;
    no_email?: number | undefined;
    phone_pro?: string | undefined;
    phone_perso?: string | undefined;
    phone_mobile?: string | undefined;
    fax?: string | undefined;
    priv?: number | undefined;
    note_public?: string | undefined;
    note_private?: string | undefined;
    statut?: number | undefined;
    birthday?: string | undefined;
    birthday_alert?: number | undefined;
    default_lang?: string | undefined;

    constructor(data?: IContactDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.module = _data["module"];
            this.id = _data["id"];
            this.entity = _data["entity"];
            this.socid = _data["socid"];
            this.lastname = _data["lastname"];
            this.firstname = _data["firstname"];
            this.poste = _data["poste"];
            this.civility_code = _data["civility_code"];
            this.fk_soc = _data["fk_soc"];
            this.socname = _data["socname"];
            this.address = _data["address"];
            this.zip = _data["zip"];
            this.town = _data["town"];
            this.country_id = _data["country_id"];
            this.country_code = _data["country_code"];
            this.state_id = _data["state_id"];
            this.email = _data["email"];
            this.no_email = _data["no_email"];
            this.phone_pro = _data["phone_pro"];
            this.phone_perso = _data["phone_perso"];
            this.phone_mobile = _data["phone_mobile"];
            this.fax = _data["fax"];
            this.priv = _data["priv"];
            this.note_public = _data["note_public"];
            this.note_private = _data["note_private"];
            this.statut = _data["statut"];
            this.birthday = _data["birthday"];
            this.birthday_alert = _data["birthday_alert"];
            this.default_lang = _data["default_lang"];
        }
    }

    static fromJS(data: any): ContactDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["module"] = this.module;
        data["id"] = this.id;
        data["entity"] = this.entity;
        data["socid"] = this.socid;
        data["lastname"] = this.lastname;
        data["firstname"] = this.firstname;
        data["poste"] = this.poste;
        data["civility_code"] = this.civility_code;
        data["fk_soc"] = this.fk_soc;
        data["socname"] = this.socname;
        data["address"] = this.address;
        data["zip"] = this.zip;
        data["town"] = this.town;
        data["country_id"] = this.country_id;
        data["country_code"] = this.country_code;
        data["state_id"] = this.state_id;
        data["email"] = this.email;
        data["no_email"] = this.no_email;
        data["phone_pro"] = this.phone_pro;
        data["phone_perso"] = this.phone_perso;
        data["phone_mobile"] = this.phone_mobile;
        data["fax"] = this.fax;
        data["priv"] = this.priv;
        data["note_public"] = this.note_public;
        data["note_private"] = this.note_private;
        data["statut"] = this.statut;
        data["birthday"] = this.birthday;
        data["birthday_alert"] = this.birthday_alert;
        data["default_lang"] = this.default_lang;
        return data;
    }
}

export interface IContactDto {
    module?: string | undefined;
    id?: number | undefined;
    entity?: string | undefined;
    socid?: string | undefined;
    lastname?: string | undefined;
    firstname?: string | undefined;
    poste?: string | undefined;
    civility_code?: string | undefined;
    fk_soc?: string | undefined;
    socname?: string | undefined;
    address?: string | undefined;
    zip?: string | undefined;
    town?: string | undefined;
    country_id?: number | undefined;
    country_code?: string | undefined;
    state_id?: number | undefined;
    email?: string | undefined;
    no_email?: number | undefined;
    phone_pro?: string | undefined;
    phone_perso?: string | undefined;
    phone_mobile?: string | undefined;
    fax?: string | undefined;
    priv?: number | undefined;
    note_public?: string | undefined;
    note_private?: string | undefined;
    statut?: number | undefined;
    birthday?: string | undefined;
    birthday_alert?: number | undefined;
    default_lang?: string | undefined;
}

export class ContactTypeDto implements IContactTypeDto {
    rowid?: number;
    code?: string | undefined;
    type?: string | undefined;
    label?: string | undefined;
    source?: string | undefined;
    module?: string | undefined;
    position?: number | undefined;

    constructor(data?: IContactTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rowid = _data["rowid"];
            this.code = _data["code"];
            this.type = _data["type"];
            this.label = _data["label"];
            this.source = _data["source"];
            this.module = _data["module"];
            this.position = _data["position"];
        }
    }

    static fromJS(data: any): ContactTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rowid"] = this.rowid;
        data["code"] = this.code;
        data["type"] = this.type;
        data["label"] = this.label;
        data["source"] = this.source;
        data["module"] = this.module;
        data["position"] = this.position;
        return data;
    }
}

export interface IContactTypeDto {
    rowid?: number;
    code?: string | undefined;
    type?: string | undefined;
    label?: string | undefined;
    source?: string | undefined;
    module?: string | undefined;
    position?: number | undefined;
}

export class CountryDto implements ICountryDto {
    id?: number;
    code?: string | undefined;
    code_iso?: string | undefined;
    label?: string | undefined;
    active?: number;

    constructor(data?: ICountryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.code_iso = _data["code_iso"];
            this.label = _data["label"];
            this.active = _data["active"];
        }
    }

    static fromJS(data: any): CountryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CountryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["code_iso"] = this.code_iso;
        data["label"] = this.label;
        data["active"] = this.active;
        return data;
    }
}

export interface ICountryDto {
    id?: number;
    code?: string | undefined;
    code_iso?: string | undefined;
    label?: string | undefined;
    active?: number;
}

export class CurrencyDto implements ICurrencyDto {
    code_iso?: string | undefined;
    label?: string | undefined;
    unicode?: string | undefined;

    constructor(data?: ICurrencyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code_iso = _data["code_iso"];
            this.label = _data["label"];
            this.unicode = _data["unicode"];
        }
    }

    static fromJS(data: any): CurrencyDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurrencyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code_iso"] = this.code_iso;
        data["label"] = this.label;
        data["unicode"] = this.unicode;
        return data;
    }
}

export interface ICurrencyDto {
    code_iso?: string | undefined;
    label?: string | undefined;
    unicode?: string | undefined;
}

export class EventTypeDto implements IEventTypeDto {
    id?: number;
    code?: string | undefined;
    type?: string | undefined;
    label?: string | undefined;
    module?: string | undefined;

    constructor(data?: IEventTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.type = _data["type"];
            this.label = _data["label"];
            this.module = _data["module"];
        }
    }

    static fromJS(data: any): EventTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new EventTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["type"] = this.type;
        data["label"] = this.label;
        data["module"] = this.module;
        return data;
    }
}

export interface IEventTypeDto {
    id?: number;
    code?: string | undefined;
    type?: string | undefined;
    label?: string | undefined;
    module?: string | undefined;
}

export class ExpenseReportTypeDto implements IExpenseReportTypeDto {
    id?: number;
    code?: string | undefined;
    label?: string | undefined;
    accountancy_code?: string | undefined;
    active?: string | undefined;
    module?: string | undefined;
    position?: number;

    constructor(data?: IExpenseReportTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.label = _data["label"];
            this.accountancy_code = _data["accountancy_code"];
            this.active = _data["active"];
            this.module = _data["module"];
            this.position = _data["position"];
        }
    }

    static fromJS(data: any): ExpenseReportTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExpenseReportTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["label"] = this.label;
        data["accountancy_code"] = this.accountancy_code;
        data["active"] = this.active;
        data["module"] = this.module;
        data["position"] = this.position;
        return data;
    }
}

export interface IExpenseReportTypeDto {
    id?: number;
    code?: string | undefined;
    label?: string | undefined;
    accountancy_code?: string | undefined;
    active?: string | undefined;
    module?: string | undefined;
    position?: number;
}

export class IncotermDto implements IIncotermDto {
    rowid?: number;
    code?: string | undefined;
    active?: number;

    constructor(data?: IIncotermDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rowid = _data["rowid"];
            this.code = _data["code"];
            this.active = _data["active"];
        }
    }

    static fromJS(data: any): IncotermDto {
        data = typeof data === 'object' ? data : {};
        let result = new IncotermDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rowid"] = this.rowid;
        data["code"] = this.code;
        data["active"] = this.active;
        return data;
    }
}

export interface IIncotermDto {
    rowid?: number;
    code?: string | undefined;
    active?: number;
}

export class InvoiceDto implements IInvoiceDto {
    module?: string | undefined;
    id?: string | undefined;
    entity?: string | undefined;
    contacts_ids?: string[] | undefined;
    fk_project?: string | undefined;
    contact_id?: string | undefined;
    ref?: string | undefined;
    statut?: string | undefined;
    status?: string | undefined;
    mode_reglement_id?: string | undefined;
    cond_reglement_id?: string | undefined;
    multicurrency_code?: string | undefined;
    multicurrency_tx?: string | undefined;
    model_pdf?: string | undefined;
    fk_bank?: number | undefined;
    fk_account?: number | undefined;
    note_public?: string | undefined;
    note_private?: string | undefined;
    total_ht?: string | undefined;
    total_tva?: string | undefined;
    total_localtax1?: string | undefined;
    total_localtax2?: string | undefined;
    total_ttc?: string | undefined;
    date_creation?: number | undefined;
    date_validation?: string | undefined;
    date_modification?: number | undefined;
    user_author?: string | undefined;
    specimen?: number | undefined;
    type?: string | undefined;
    totalpaid?: number | undefined;
    remaintopay?: string | undefined;
    fk_incoterms?: string | undefined;
    location_incoterms?: string | undefined;
    brouillon?: number | undefined;
    socid?: string | undefined;
    fk_user_author?: string | undefined;
    date?: number | undefined;
    datem?: number | undefined;
    revenuestamp?: string | undefined;
    paye?: string | undefined;
    date_lim_reglement?: number | undefined;
    cond_reglement_code?: string | undefined;
    cond_reglement_doc?: string | undefined;
    mode_reglement_code?: string | undefined;
    date_pointoftax?: string | undefined;
    fk_multicurrency?: string | undefined;
    multicurrency_total_ht?: string | undefined;
    multicurrency_total_tva?: string | undefined;
    multicurrency_total_ttc?: string | undefined;
    situation_final?: string | undefined;
    retained_warranty?: string | undefined;
    retained_warranty_date_limit?: number | undefined;
    retained_warranty_fk_cond_reglement?: string | undefined;

    constructor(data?: IInvoiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.module = _data["module"];
            this.id = _data["id"];
            this.entity = _data["entity"];
            if (Array.isArray(_data["contacts_ids"])) {
                this.contacts_ids = [] as any;
                for (let item of _data["contacts_ids"])
                    this.contacts_ids!.push(item);
            }
            this.fk_project = _data["fk_project"];
            this.contact_id = _data["contact_id"];
            this.ref = _data["ref"];
            this.statut = _data["statut"];
            this.status = _data["status"];
            this.mode_reglement_id = _data["mode_reglement_id"];
            this.cond_reglement_id = _data["cond_reglement_id"];
            this.multicurrency_code = _data["multicurrency_code"];
            this.multicurrency_tx = _data["multicurrency_tx"];
            this.model_pdf = _data["model_pdf"];
            this.fk_bank = _data["fk_bank"];
            this.fk_account = _data["fk_account"];
            this.note_public = _data["note_public"];
            this.note_private = _data["note_private"];
            this.total_ht = _data["total_ht"];
            this.total_tva = _data["total_tva"];
            this.total_localtax1 = _data["total_localtax1"];
            this.total_localtax2 = _data["total_localtax2"];
            this.total_ttc = _data["total_ttc"];
            this.date_creation = _data["date_creation"];
            this.date_validation = _data["date_validation"];
            this.date_modification = _data["date_modification"];
            this.user_author = _data["user_author"];
            this.specimen = _data["specimen"];
            this.type = _data["type"];
            this.totalpaid = _data["totalpaid"];
            this.remaintopay = _data["remaintopay"];
            this.fk_incoterms = _data["fk_incoterms"];
            this.location_incoterms = _data["location_incoterms"];
            this.brouillon = _data["brouillon"];
            this.socid = _data["socid"];
            this.fk_user_author = _data["fk_user_author"];
            this.date = _data["date"];
            this.datem = _data["datem"];
            this.revenuestamp = _data["revenuestamp"];
            this.paye = _data["paye"];
            this.date_lim_reglement = _data["date_lim_reglement"];
            this.cond_reglement_code = _data["cond_reglement_code"];
            this.cond_reglement_doc = _data["cond_reglement_doc"];
            this.mode_reglement_code = _data["mode_reglement_code"];
            this.date_pointoftax = _data["date_pointoftax"];
            this.fk_multicurrency = _data["fk_multicurrency"];
            this.multicurrency_total_ht = _data["multicurrency_total_ht"];
            this.multicurrency_total_tva = _data["multicurrency_total_tva"];
            this.multicurrency_total_ttc = _data["multicurrency_total_ttc"];
            this.situation_final = _data["situation_final"];
            this.retained_warranty = _data["retained_warranty"];
            this.retained_warranty_date_limit = _data["retained_warranty_date_limit"];
            this.retained_warranty_fk_cond_reglement = _data["retained_warranty_fk_cond_reglement"];
        }
    }

    static fromJS(data: any): InvoiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["module"] = this.module;
        data["id"] = this.id;
        data["entity"] = this.entity;
        if (Array.isArray(this.contacts_ids)) {
            data["contacts_ids"] = [];
            for (let item of this.contacts_ids)
                data["contacts_ids"].push(item);
        }
        data["fk_project"] = this.fk_project;
        data["contact_id"] = this.contact_id;
        data["ref"] = this.ref;
        data["statut"] = this.statut;
        data["status"] = this.status;
        data["mode_reglement_id"] = this.mode_reglement_id;
        data["cond_reglement_id"] = this.cond_reglement_id;
        data["multicurrency_code"] = this.multicurrency_code;
        data["multicurrency_tx"] = this.multicurrency_tx;
        data["model_pdf"] = this.model_pdf;
        data["fk_bank"] = this.fk_bank;
        data["fk_account"] = this.fk_account;
        data["note_public"] = this.note_public;
        data["note_private"] = this.note_private;
        data["total_ht"] = this.total_ht;
        data["total_tva"] = this.total_tva;
        data["total_localtax1"] = this.total_localtax1;
        data["total_localtax2"] = this.total_localtax2;
        data["total_ttc"] = this.total_ttc;
        data["date_creation"] = this.date_creation;
        data["date_validation"] = this.date_validation;
        data["date_modification"] = this.date_modification;
        data["user_author"] = this.user_author;
        data["specimen"] = this.specimen;
        data["type"] = this.type;
        data["totalpaid"] = this.totalpaid;
        data["remaintopay"] = this.remaintopay;
        data["fk_incoterms"] = this.fk_incoterms;
        data["location_incoterms"] = this.location_incoterms;
        data["brouillon"] = this.brouillon;
        data["socid"] = this.socid;
        data["fk_user_author"] = this.fk_user_author;
        data["date"] = this.date;
        data["datem"] = this.datem;
        data["revenuestamp"] = this.revenuestamp;
        data["paye"] = this.paye;
        data["date_lim_reglement"] = this.date_lim_reglement;
        data["cond_reglement_code"] = this.cond_reglement_code;
        data["cond_reglement_doc"] = this.cond_reglement_doc;
        data["mode_reglement_code"] = this.mode_reglement_code;
        data["date_pointoftax"] = this.date_pointoftax;
        data["fk_multicurrency"] = this.fk_multicurrency;
        data["multicurrency_total_ht"] = this.multicurrency_total_ht;
        data["multicurrency_total_tva"] = this.multicurrency_total_tva;
        data["multicurrency_total_ttc"] = this.multicurrency_total_ttc;
        data["situation_final"] = this.situation_final;
        data["retained_warranty"] = this.retained_warranty;
        data["retained_warranty_date_limit"] = this.retained_warranty_date_limit;
        data["retained_warranty_fk_cond_reglement"] = this.retained_warranty_fk_cond_reglement;
        return data;
    }
}

export interface IInvoiceDto {
    module?: string | undefined;
    id?: string | undefined;
    entity?: string | undefined;
    contacts_ids?: string[] | undefined;
    fk_project?: string | undefined;
    contact_id?: string | undefined;
    ref?: string | undefined;
    statut?: string | undefined;
    status?: string | undefined;
    mode_reglement_id?: string | undefined;
    cond_reglement_id?: string | undefined;
    multicurrency_code?: string | undefined;
    multicurrency_tx?: string | undefined;
    model_pdf?: string | undefined;
    fk_bank?: number | undefined;
    fk_account?: number | undefined;
    note_public?: string | undefined;
    note_private?: string | undefined;
    total_ht?: string | undefined;
    total_tva?: string | undefined;
    total_localtax1?: string | undefined;
    total_localtax2?: string | undefined;
    total_ttc?: string | undefined;
    date_creation?: number | undefined;
    date_validation?: string | undefined;
    date_modification?: number | undefined;
    user_author?: string | undefined;
    specimen?: number | undefined;
    type?: string | undefined;
    totalpaid?: number | undefined;
    remaintopay?: string | undefined;
    fk_incoterms?: string | undefined;
    location_incoterms?: string | undefined;
    brouillon?: number | undefined;
    socid?: string | undefined;
    fk_user_author?: string | undefined;
    date?: number | undefined;
    datem?: number | undefined;
    revenuestamp?: string | undefined;
    paye?: string | undefined;
    date_lim_reglement?: number | undefined;
    cond_reglement_code?: string | undefined;
    cond_reglement_doc?: string | undefined;
    mode_reglement_code?: string | undefined;
    date_pointoftax?: string | undefined;
    fk_multicurrency?: string | undefined;
    multicurrency_total_ht?: string | undefined;
    multicurrency_total_tva?: string | undefined;
    multicurrency_total_ttc?: string | undefined;
    situation_final?: string | undefined;
    retained_warranty?: string | undefined;
    retained_warranty_date_limit?: number | undefined;
    retained_warranty_fk_cond_reglement?: string | undefined;
}

export class LegalFormDto implements ILegalFormDto {
    rowid?: number;
    code?: number;
    fk_pays?: number;
    libelle?: string | undefined;
    isvatexempted?: number;
    active?: number;
    module?: string | undefined;
    position?: number;

    constructor(data?: ILegalFormDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rowid = _data["rowid"];
            this.code = _data["code"];
            this.fk_pays = _data["fk_pays"];
            this.libelle = _data["libelle"];
            this.isvatexempted = _data["isvatexempted"];
            this.active = _data["active"];
            this.module = _data["module"];
            this.position = _data["position"];
        }
    }

    static fromJS(data: any): LegalFormDto {
        data = typeof data === 'object' ? data : {};
        let result = new LegalFormDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rowid"] = this.rowid;
        data["code"] = this.code;
        data["fk_pays"] = this.fk_pays;
        data["libelle"] = this.libelle;
        data["isvatexempted"] = this.isvatexempted;
        data["active"] = this.active;
        data["module"] = this.module;
        data["position"] = this.position;
        return data;
    }
}

export interface ILegalFormDto {
    rowid?: number;
    code?: number;
    fk_pays?: number;
    libelle?: string | undefined;
    isvatexempted?: number;
    active?: number;
    module?: string | undefined;
    position?: number;
}

export class LoginDto implements ILoginDto {
    code?: number;
    token?: string | undefined;
    entity?: string | undefined;
    message?: string | undefined;

    constructor(data?: ILoginDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.token = _data["token"];
            this.entity = _data["entity"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): LoginDto {
        data = typeof data === 'object' ? data : {};
        let result = new LoginDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["token"] = this.token;
        data["entity"] = this.entity;
        data["message"] = this.message;
        return data;
    }
}

export interface ILoginDto {
    code?: number;
    token?: string | undefined;
    entity?: string | undefined;
    message?: string | undefined;
}

export class LoginResponseDto implements ILoginResponseDto {
    success?: LoginDto;

    constructor(data?: ILoginResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] ? LoginDto.fromJS(_data["success"]) : <any>undefined;
        }
    }

    static fromJS(data: any): LoginResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new LoginResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success ? this.success.toJSON() : <any>undefined;
        return data;
    }
}

export interface ILoginResponseDto {
    success?: LoginDto;
}

export class ManufacturingOrderDto implements IManufacturingOrderDto {
    module?: string | undefined;
    id?: number;
    fk_project?: number | undefined;
    ref?: string | undefined;
    status?: number | undefined;
    note_public?: string | undefined;
    note_private?: string | undefined;
    lines?: any[] | undefined;
    specimen?: number | undefined;
    mrptype?: number | undefined;
    label?: string | undefined;
    qty?: number | undefined;
    fk_soc?: number | undefined;
    socid?: number | undefined;
    tms?: number | undefined;
    fk_product?: number | undefined;
    date_start_planned?: number | undefined;
    date_end_planned?: number | undefined;
    fk_bom?: number | undefined;
    line?: any[] | undefined;

    constructor(data?: IManufacturingOrderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.module = _data["module"];
            this.id = _data["id"];
            this.fk_project = _data["fk_project"];
            this.ref = _data["ref"];
            this.status = _data["status"];
            this.note_public = _data["note_public"];
            this.note_private = _data["note_private"];
            if (Array.isArray(_data["lines"])) {
                this.lines = [] as any;
                for (let item of _data["lines"])
                    this.lines!.push(item);
            }
            this.specimen = _data["specimen"];
            this.mrptype = _data["mrptype"];
            this.label = _data["label"];
            this.qty = _data["qty"];
            this.fk_soc = _data["fk_soc"];
            this.socid = _data["socid"];
            this.tms = _data["tms"];
            this.fk_product = _data["fk_product"];
            this.date_start_planned = _data["date_start_planned"];
            this.date_end_planned = _data["date_end_planned"];
            this.fk_bom = _data["fk_bom"];
            if (Array.isArray(_data["line"])) {
                this.line = [] as any;
                for (let item of _data["line"])
                    this.line!.push(item);
            }
        }
    }

    static fromJS(data: any): ManufacturingOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new ManufacturingOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["module"] = this.module;
        data["id"] = this.id;
        data["fk_project"] = this.fk_project;
        data["ref"] = this.ref;
        data["status"] = this.status;
        data["note_public"] = this.note_public;
        data["note_private"] = this.note_private;
        if (Array.isArray(this.lines)) {
            data["lines"] = [];
            for (let item of this.lines)
                data["lines"].push(item);
        }
        data["specimen"] = this.specimen;
        data["mrptype"] = this.mrptype;
        data["label"] = this.label;
        data["qty"] = this.qty;
        data["fk_soc"] = this.fk_soc;
        data["socid"] = this.socid;
        data["tms"] = this.tms;
        data["fk_product"] = this.fk_product;
        data["date_start_planned"] = this.date_start_planned;
        data["date_end_planned"] = this.date_end_planned;
        data["fk_bom"] = this.fk_bom;
        if (Array.isArray(this.line)) {
            data["line"] = [];
            for (let item of this.line)
                data["line"].push(item);
        }
        return data;
    }
}

export interface IManufacturingOrderDto {
    module?: string | undefined;
    id?: number;
    fk_project?: number | undefined;
    ref?: string | undefined;
    status?: number | undefined;
    note_public?: string | undefined;
    note_private?: string | undefined;
    lines?: any[] | undefined;
    specimen?: number | undefined;
    mrptype?: number | undefined;
    label?: string | undefined;
    qty?: number | undefined;
    fk_soc?: number | undefined;
    socid?: number | undefined;
    tms?: number | undefined;
    fk_product?: number | undefined;
    date_start_planned?: number | undefined;
    date_end_planned?: number | undefined;
    fk_bom?: number | undefined;
    line?: any[] | undefined;
}

export class MemberDto implements IMemberDto {
    module?: string | undefined;
    id?: number | undefined;
    entity?: number | undefined;
    fk_project?: number | undefined;
    contact_id?: number | undefined;
    ref?: string | undefined;
    country_id?: number | undefined;
    country_code?: string | undefined;
    firstname?: string | undefined;
    lastname?: string | undefined;
    fullname?: string | undefined;
    company?: string | undefined;
    societe?: string | undefined;
    address?: string | undefined;
    zip?: string | undefined;
    town?: string | undefined;
    email?: string | undefined;
    phone?: number | undefined;
    morphy?: string | undefined;
    gender?: string | undefined;
    birth?: string | undefined;
    typeid?: string | undefined;
    type?: string | undefined;

    constructor(data?: IMemberDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.module = _data["module"];
            this.id = _data["id"];
            this.entity = _data["entity"];
            this.fk_project = _data["fk_project"];
            this.contact_id = _data["contact_id"];
            this.ref = _data["ref"];
            this.country_id = _data["country_id"];
            this.country_code = _data["country_code"];
            this.firstname = _data["firstname"];
            this.lastname = _data["lastname"];
            this.fullname = _data["fullname"];
            this.company = _data["company"];
            this.societe = _data["societe"];
            this.address = _data["address"];
            this.zip = _data["zip"];
            this.town = _data["town"];
            this.email = _data["email"];
            this.phone = _data["phone"];
            this.morphy = _data["morphy"];
            this.gender = _data["gender"];
            this.birth = _data["birth"];
            this.typeid = _data["typeid"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): MemberDto {
        data = typeof data === 'object' ? data : {};
        let result = new MemberDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["module"] = this.module;
        data["id"] = this.id;
        data["entity"] = this.entity;
        data["fk_project"] = this.fk_project;
        data["contact_id"] = this.contact_id;
        data["ref"] = this.ref;
        data["country_id"] = this.country_id;
        data["country_code"] = this.country_code;
        data["firstname"] = this.firstname;
        data["lastname"] = this.lastname;
        data["fullname"] = this.fullname;
        data["company"] = this.company;
        data["societe"] = this.societe;
        data["address"] = this.address;
        data["zip"] = this.zip;
        data["town"] = this.town;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["morphy"] = this.morphy;
        data["gender"] = this.gender;
        data["birth"] = this.birth;
        data["typeid"] = this.typeid;
        data["type"] = this.type;
        return data;
    }
}

export interface IMemberDto {
    module?: string | undefined;
    id?: number | undefined;
    entity?: number | undefined;
    fk_project?: number | undefined;
    contact_id?: number | undefined;
    ref?: string | undefined;
    country_id?: number | undefined;
    country_code?: string | undefined;
    firstname?: string | undefined;
    lastname?: string | undefined;
    fullname?: string | undefined;
    company?: string | undefined;
    societe?: string | undefined;
    address?: string | undefined;
    zip?: string | undefined;
    town?: string | undefined;
    email?: string | undefined;
    phone?: number | undefined;
    morphy?: string | undefined;
    gender?: string | undefined;
    birth?: string | undefined;
    typeid?: string | undefined;
    type?: string | undefined;
}

export class MembersTypeDto implements IMembersTypeDto {
    id?: number;
    ref?: string | undefined;
    status?: string | undefined;
    specimen?: number | undefined;
    label?: string | undefined;
    morphy?: string | undefined;
    vote?: string | undefined;
    description?: string | undefined;
    mail_valid?: string | undefined;

    constructor(data?: IMembersTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.ref = _data["ref"];
            this.status = _data["status"];
            this.specimen = _data["specimen"];
            this.label = _data["label"];
            this.morphy = _data["morphy"];
            this.vote = _data["vote"];
            this.description = _data["description"];
            this.mail_valid = _data["mail_valid"];
        }
    }

    static fromJS(data: any): MembersTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new MembersTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["ref"] = this.ref;
        data["status"] = this.status;
        data["specimen"] = this.specimen;
        data["label"] = this.label;
        data["morphy"] = this.morphy;
        data["vote"] = this.vote;
        data["description"] = this.description;
        data["mail_valid"] = this.mail_valid;
        return data;
    }
}

export interface IMembersTypeDto {
    id?: number;
    ref?: string | undefined;
    status?: string | undefined;
    specimen?: number | undefined;
    label?: string | undefined;
    morphy?: string | undefined;
    vote?: string | undefined;
    description?: string | undefined;
    mail_valid?: string | undefined;
}

export class OrderDto implements IOrderDto {
    module?: string | undefined;
    id?: number | undefined;
    entity?: string | undefined;
    import_key?: string | undefined;
    fk_project?: number | undefined;
    contact_id?: number | undefined;
    ref?: string | undefined;
    ref_ext?: string | undefined;
    int?: string | undefined;
    country_id?: number | undefined;
    country_code?: string | undefined;
    state_id?: number | undefined;
    region_id?: number | undefined;
    mode_reglement_id?: number | undefined;
    cond_reglement_id?: number | undefined;
    demand_reason_id?: number | undefined;
    transport_mode_id?: number | undefined;
    shipping_method_id?: number | undefined;
    shipping_method?: number | undefined;
    multicurrency_code?: string | undefined;
    multicurrency_tx?: string | undefined;
    fk_bank?: number | undefined;
    fk_account?: number | undefined;
    note_public?: string | undefined;
    note_private?: string | undefined;
    total_ht?: string | undefined;
    total_tva?: string | undefined;
    total_localtax1?: string | undefined;
    total_localtax2?: string | undefined;
    total_ttc?: string | undefined;
    lines?: any[] | undefined;
    name?: string | undefined;
    lastname?: string | undefined;
    firstname?: string | undefined;
    civility_id?: number | undefined;
    date_creation?: number | undefined;
    date_validation?: number | undefined;
    date_modification?: number | undefined;
    user_author?: string | undefined;
    user_creation?: string | undefined;
    user_creation_id?: number | undefined;
    user_valid?: string | undefined;
    user_validation?: string | undefined;
    user_validation_id?: number | undefined;
    user_closing_id?: number | undefined;
    specimen?: number | undefined;
    code?: string | undefined;
    fk_incoterms?: string | undefined;
    socid?: number | undefined;
    ref_client?: string | undefined;
    ref_customer?: string | undefined;
    contactId?: number | undefined;
    billed?: number | undefined;
    cond_reglement_code?: string | undefined;
    cond_reglement_doc?: string | undefined;
    deposit_percent?: string | undefined;
    mode_reglement_code?: string | undefined;
    availability_id?: number | undefined;
    availability_code?: string | undefined;
    availability?: string | undefined;
    demand_reason_code?: string | undefined;
    date?: number | undefined;
    date_commande?: number | undefined;
    delivery_date?: number | undefined;
    fk_remise_except?: number | undefined;
    remise_percent?: string | undefined;
    remise_absolue?: string | undefined;
    info_bits?: number | undefined;
    rang?: number | undefined;
    special_code?: number | undefined;
    warehouse_id?: number | undefined;
    user_author_id?: number | undefined;
    module_source?: string | undefined;
    pos_source?: string | undefined;
    online_payment_url?: string | undefined;

    constructor(data?: IOrderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.module = _data["module"];
            this.id = _data["id"];
            this.entity = _data["entity"];
            this.import_key = _data["import_key"];
            this.fk_project = _data["fk_project"];
            this.contact_id = _data["contact_id"];
            this.ref = _data["ref"];
            this.ref_ext = _data["ref_ext"];
            this.int = _data["int"];
            this.country_id = _data["country_id"];
            this.country_code = _data["country_code"];
            this.state_id = _data["state_id"];
            this.region_id = _data["region_id"];
            this.mode_reglement_id = _data["mode_reglement_id"];
            this.cond_reglement_id = _data["cond_reglement_id"];
            this.demand_reason_id = _data["demand_reason_id"];
            this.transport_mode_id = _data["transport_mode_id"];
            this.shipping_method_id = _data["shipping_method_id"];
            this.shipping_method = _data["shipping_method"];
            this.multicurrency_code = _data["multicurrency_code"];
            this.multicurrency_tx = _data["multicurrency_tx"];
            this.fk_bank = _data["fk_bank"];
            this.fk_account = _data["fk_account"];
            this.note_public = _data["note_public"];
            this.note_private = _data["note_private"];
            this.total_ht = _data["total_ht"];
            this.total_tva = _data["total_tva"];
            this.total_localtax1 = _data["total_localtax1"];
            this.total_localtax2 = _data["total_localtax2"];
            this.total_ttc = _data["total_ttc"];
            if (Array.isArray(_data["lines"])) {
                this.lines = [] as any;
                for (let item of _data["lines"])
                    this.lines!.push(item);
            }
            this.name = _data["name"];
            this.lastname = _data["lastname"];
            this.firstname = _data["firstname"];
            this.civility_id = _data["civility_id"];
            this.date_creation = _data["date_creation"];
            this.date_validation = _data["date_validation"];
            this.date_modification = _data["date_modification"];
            this.user_author = _data["user_author"];
            this.user_creation = _data["user_creation"];
            this.user_creation_id = _data["user_creation_id"];
            this.user_valid = _data["user_valid"];
            this.user_validation = _data["user_validation"];
            this.user_validation_id = _data["user_validation_id"];
            this.user_closing_id = _data["user_closing_id"];
            this.specimen = _data["specimen"];
            this.code = _data["code"];
            this.fk_incoterms = _data["fk_incoterms"];
            this.socid = _data["socid"];
            this.ref_client = _data["ref_client"];
            this.ref_customer = _data["ref_customer"];
            this.contactId = _data["contactId"];
            this.billed = _data["billed"];
            this.cond_reglement_code = _data["cond_reglement_code"];
            this.cond_reglement_doc = _data["cond_reglement_doc"];
            this.deposit_percent = _data["deposit_percent"];
            this.mode_reglement_code = _data["mode_reglement_code"];
            this.availability_id = _data["availability_id"];
            this.availability_code = _data["availability_code"];
            this.availability = _data["availability"];
            this.demand_reason_code = _data["demand_reason_code"];
            this.date = _data["date"];
            this.date_commande = _data["date_commande"];
            this.delivery_date = _data["delivery_date"];
            this.fk_remise_except = _data["fk_remise_except"];
            this.remise_percent = _data["remise_percent"];
            this.remise_absolue = _data["remise_absolue"];
            this.info_bits = _data["info_bits"];
            this.rang = _data["rang"];
            this.special_code = _data["special_code"];
            this.warehouse_id = _data["warehouse_id"];
            this.user_author_id = _data["user_author_id"];
            this.module_source = _data["module_source"];
            this.pos_source = _data["pos_source"];
            this.online_payment_url = _data["online_payment_url"];
        }
    }

    static fromJS(data: any): OrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["module"] = this.module;
        data["id"] = this.id;
        data["entity"] = this.entity;
        data["import_key"] = this.import_key;
        data["fk_project"] = this.fk_project;
        data["contact_id"] = this.contact_id;
        data["ref"] = this.ref;
        data["ref_ext"] = this.ref_ext;
        data["int"] = this.int;
        data["country_id"] = this.country_id;
        data["country_code"] = this.country_code;
        data["state_id"] = this.state_id;
        data["region_id"] = this.region_id;
        data["mode_reglement_id"] = this.mode_reglement_id;
        data["cond_reglement_id"] = this.cond_reglement_id;
        data["demand_reason_id"] = this.demand_reason_id;
        data["transport_mode_id"] = this.transport_mode_id;
        data["shipping_method_id"] = this.shipping_method_id;
        data["shipping_method"] = this.shipping_method;
        data["multicurrency_code"] = this.multicurrency_code;
        data["multicurrency_tx"] = this.multicurrency_tx;
        data["fk_bank"] = this.fk_bank;
        data["fk_account"] = this.fk_account;
        data["note_public"] = this.note_public;
        data["note_private"] = this.note_private;
        data["total_ht"] = this.total_ht;
        data["total_tva"] = this.total_tva;
        data["total_localtax1"] = this.total_localtax1;
        data["total_localtax2"] = this.total_localtax2;
        data["total_ttc"] = this.total_ttc;
        if (Array.isArray(this.lines)) {
            data["lines"] = [];
            for (let item of this.lines)
                data["lines"].push(item);
        }
        data["name"] = this.name;
        data["lastname"] = this.lastname;
        data["firstname"] = this.firstname;
        data["civility_id"] = this.civility_id;
        data["date_creation"] = this.date_creation;
        data["date_validation"] = this.date_validation;
        data["date_modification"] = this.date_modification;
        data["user_author"] = this.user_author;
        data["user_creation"] = this.user_creation;
        data["user_creation_id"] = this.user_creation_id;
        data["user_valid"] = this.user_valid;
        data["user_validation"] = this.user_validation;
        data["user_validation_id"] = this.user_validation_id;
        data["user_closing_id"] = this.user_closing_id;
        data["specimen"] = this.specimen;
        data["code"] = this.code;
        data["fk_incoterms"] = this.fk_incoterms;
        data["socid"] = this.socid;
        data["ref_client"] = this.ref_client;
        data["ref_customer"] = this.ref_customer;
        data["contactId"] = this.contactId;
        data["billed"] = this.billed;
        data["cond_reglement_code"] = this.cond_reglement_code;
        data["cond_reglement_doc"] = this.cond_reglement_doc;
        data["deposit_percent"] = this.deposit_percent;
        data["mode_reglement_code"] = this.mode_reglement_code;
        data["availability_id"] = this.availability_id;
        data["availability_code"] = this.availability_code;
        data["availability"] = this.availability;
        data["demand_reason_code"] = this.demand_reason_code;
        data["date"] = this.date;
        data["date_commande"] = this.date_commande;
        data["delivery_date"] = this.delivery_date;
        data["fk_remise_except"] = this.fk_remise_except;
        data["remise_percent"] = this.remise_percent;
        data["remise_absolue"] = this.remise_absolue;
        data["info_bits"] = this.info_bits;
        data["rang"] = this.rang;
        data["special_code"] = this.special_code;
        data["warehouse_id"] = this.warehouse_id;
        data["user_author_id"] = this.user_author_id;
        data["module_source"] = this.module_source;
        data["pos_source"] = this.pos_source;
        data["online_payment_url"] = this.online_payment_url;
        return data;
    }
}

export interface IOrderDto {
    module?: string | undefined;
    id?: number | undefined;
    entity?: string | undefined;
    import_key?: string | undefined;
    fk_project?: number | undefined;
    contact_id?: number | undefined;
    ref?: string | undefined;
    ref_ext?: string | undefined;
    int?: string | undefined;
    country_id?: number | undefined;
    country_code?: string | undefined;
    state_id?: number | undefined;
    region_id?: number | undefined;
    mode_reglement_id?: number | undefined;
    cond_reglement_id?: number | undefined;
    demand_reason_id?: number | undefined;
    transport_mode_id?: number | undefined;
    shipping_method_id?: number | undefined;
    shipping_method?: number | undefined;
    multicurrency_code?: string | undefined;
    multicurrency_tx?: string | undefined;
    fk_bank?: number | undefined;
    fk_account?: number | undefined;
    note_public?: string | undefined;
    note_private?: string | undefined;
    total_ht?: string | undefined;
    total_tva?: string | undefined;
    total_localtax1?: string | undefined;
    total_localtax2?: string | undefined;
    total_ttc?: string | undefined;
    lines?: any[] | undefined;
    name?: string | undefined;
    lastname?: string | undefined;
    firstname?: string | undefined;
    civility_id?: number | undefined;
    date_creation?: number | undefined;
    date_validation?: number | undefined;
    date_modification?: number | undefined;
    user_author?: string | undefined;
    user_creation?: string | undefined;
    user_creation_id?: number | undefined;
    user_valid?: string | undefined;
    user_validation?: string | undefined;
    user_validation_id?: number | undefined;
    user_closing_id?: number | undefined;
    specimen?: number | undefined;
    code?: string | undefined;
    fk_incoterms?: string | undefined;
    socid?: number | undefined;
    ref_client?: string | undefined;
    ref_customer?: string | undefined;
    contactId?: number | undefined;
    billed?: number | undefined;
    cond_reglement_code?: string | undefined;
    cond_reglement_doc?: string | undefined;
    deposit_percent?: string | undefined;
    mode_reglement_code?: string | undefined;
    availability_id?: number | undefined;
    availability_code?: string | undefined;
    availability?: string | undefined;
    demand_reason_code?: string | undefined;
    date?: number | undefined;
    date_commande?: number | undefined;
    delivery_date?: number | undefined;
    fk_remise_except?: number | undefined;
    remise_percent?: string | undefined;
    remise_absolue?: string | undefined;
    info_bits?: number | undefined;
    rang?: number | undefined;
    special_code?: number | undefined;
    warehouse_id?: number | undefined;
    user_author_id?: number | undefined;
    module_source?: string | undefined;
    pos_source?: string | undefined;
    online_payment_url?: string | undefined;
}

export class OrderingMethodDto implements IOrderingMethodDto {
    rowid?: number;
    code?: string | undefined;
    label?: string | undefined;
    module?: string | undefined;

    constructor(data?: IOrderingMethodDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rowid = _data["rowid"];
            this.code = _data["code"];
            this.label = _data["label"];
            this.module = _data["module"];
        }
    }

    static fromJS(data: any): OrderingMethodDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderingMethodDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rowid"] = this.rowid;
        data["code"] = this.code;
        data["label"] = this.label;
        data["module"] = this.module;
        return data;
    }
}

export interface IOrderingMethodDto {
    rowid?: number;
    code?: string | undefined;
    label?: string | undefined;
    module?: string | undefined;
}

export class OrderingOriginDto implements IOrderingOriginDto {
    rowid?: number;
    code?: string | undefined;
    label?: string | undefined;
    module?: string | undefined;

    constructor(data?: IOrderingOriginDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rowid = _data["rowid"];
            this.code = _data["code"];
            this.label = _data["label"];
            this.module = _data["module"];
        }
    }

    static fromJS(data: any): OrderingOriginDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderingOriginDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rowid"] = this.rowid;
        data["code"] = this.code;
        data["label"] = this.label;
        data["module"] = this.module;
        return data;
    }
}

export interface IOrderingOriginDto {
    rowid?: number;
    code?: string | undefined;
    label?: string | undefined;
    module?: string | undefined;
}

export class PaymentTermsDto implements IPaymentTermsDto {
    id?: string | undefined;
    code?: string | undefined;
    sortorder?: string | undefined;
    label?: string | undefined;
    descr?: string | undefined;
    type_cdr?: string | undefined;
    nbjour?: string | undefined;
    decalage?: string | undefined;
    module?: string | undefined;

    constructor(data?: IPaymentTermsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.sortorder = _data["sortorder"];
            this.label = _data["label"];
            this.descr = _data["descr"];
            this.type_cdr = _data["type_cdr"];
            this.nbjour = _data["nbjour"];
            this.decalage = _data["decalage"];
            this.module = _data["module"];
        }
    }

    static fromJS(data: any): PaymentTermsDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentTermsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["sortorder"] = this.sortorder;
        data["label"] = this.label;
        data["descr"] = this.descr;
        data["type_cdr"] = this.type_cdr;
        data["nbjour"] = this.nbjour;
        data["decalage"] = this.decalage;
        data["module"] = this.module;
        return data;
    }
}

export interface IPaymentTermsDto {
    id?: string | undefined;
    code?: string | undefined;
    sortorder?: string | undefined;
    label?: string | undefined;
    descr?: string | undefined;
    type_cdr?: string | undefined;
    nbjour?: string | undefined;
    decalage?: string | undefined;
    module?: string | undefined;
}

export class PaymentTypeDto implements IPaymentTypeDto {
    id?: number;
    code?: string | undefined;
    type?: string | undefined;
    label?: string | undefined;
    module?: string | undefined;

    constructor(data?: IPaymentTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.type = _data["type"];
            this.label = _data["label"];
            this.module = _data["module"];
        }
    }

    static fromJS(data: any): PaymentTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["type"] = this.type;
        data["label"] = this.label;
        data["module"] = this.module;
        return data;
    }
}

export interface IPaymentTypeDto {
    id?: number;
    code?: string | undefined;
    type?: string | undefined;
    label?: string | undefined;
    module?: string | undefined;
}

export class ProductDto implements IProductDto {
    module?: string | undefined;
    id?: number;
    entity?: string | undefined;
    ref?: string | undefined;
    status?: string | undefined;
    country_id?: string | undefined;
    country_code?: string | undefined;
    state_id?: string | undefined;
    region_id?: string | undefined;
    note_public?: string | undefined;
    note_private?: string | undefined;
    date_creation?: string | undefined;
    date_validation?: string | undefined;
    date_modification?: string | undefined;
    date_update?: string | undefined;
    user_creation_id?: number | undefined;
    user_valid?: number | undefined;
    user_validation_id?: number | undefined;
    user_closing_id?: number | undefined;
    user_modification_id?: number | undefined;
    specimen?: number | undefined;
    labelStatus?: string | undefined;
    label?: string | undefined;
    description?: string | undefined;
    type?: string | undefined;
    price?: string | undefined;
    price_formated?: string | undefined;
    price_ttc?: string | undefined;
    price_ttc_formated?: string | undefined;
    price_min?: string | undefined;
    price_min_ttc?: string | undefined;
    price_base_type?: string | undefined;
    default_vat_code?: string | undefined;
    tva_tx?: string | undefined;
    remise_percent?: string | undefined;
    localtax1_tx?: string | undefined;
    localtax2_tx?: string | undefined;
    localtax1_type?: string | undefined;
    localtax2_type?: string | undefined;
    pmp?: string | undefined;
    seuil_stock_alerte?: string | undefined;
    desiredstock?: string | undefined;
    duration?: string | undefined;
    fk_default_workstation?: number | undefined;
    status_buy?: string | undefined;
    finished?: string | undefined;
    status_batch?: string | undefined;
    batch_mask?: string | undefined;
    customcode?: string | undefined;
    url?: string | undefined;
    weight?: string | undefined;
    weight_units?: string | undefined;
    length?: string | undefined;
    length_units?: string | undefined;
    width?: string | undefined;
    width_units?: string | undefined;
    height?: string | undefined;
    height_units?: string | undefined;
    surface?: string | undefined;
    surface_units?: string | undefined;
    volume?: string | undefined;
    volume_units?: string | undefined;
    accountancy_code_sell?: string | undefined;
    accountancy_code_sell_intra?: string | undefined;
    accountancy_code_sell_export?: string | undefined;
    accountancy_code_buy?: string | undefined;
    accountancy_code_buy_intra?: string | undefined;
    accountancy_code_buy_export?: string | undefined;
    barcode?: string | undefined;
    price_autogen?: string | undefined;
    mandatory_period?: string | undefined;

    constructor(data?: IProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.module = _data["module"];
            this.id = _data["id"];
            this.entity = _data["entity"];
            this.ref = _data["ref"];
            this.status = _data["status"];
            this.country_id = _data["country_id"];
            this.country_code = _data["country_code"];
            this.state_id = _data["state_id"];
            this.region_id = _data["region_id"];
            this.note_public = _data["note_public"];
            this.note_private = _data["note_private"];
            this.date_creation = _data["date_creation"];
            this.date_validation = _data["date_validation"];
            this.date_modification = _data["date_modification"];
            this.date_update = _data["date_update"];
            this.user_creation_id = _data["user_creation_id"];
            this.user_valid = _data["user_valid"];
            this.user_validation_id = _data["user_validation_id"];
            this.user_closing_id = _data["user_closing_id"];
            this.user_modification_id = _data["user_modification_id"];
            this.specimen = _data["specimen"];
            this.labelStatus = _data["labelStatus"];
            this.label = _data["label"];
            this.description = _data["description"];
            this.type = _data["type"];
            this.price = _data["price"];
            this.price_formated = _data["price_formated"];
            this.price_ttc = _data["price_ttc"];
            this.price_ttc_formated = _data["price_ttc_formated"];
            this.price_min = _data["price_min"];
            this.price_min_ttc = _data["price_min_ttc"];
            this.price_base_type = _data["price_base_type"];
            this.default_vat_code = _data["default_vat_code"];
            this.tva_tx = _data["tva_tx"];
            this.remise_percent = _data["remise_percent"];
            this.localtax1_tx = _data["localtax1_tx"];
            this.localtax2_tx = _data["localtax2_tx"];
            this.localtax1_type = _data["localtax1_type"];
            this.localtax2_type = _data["localtax2_type"];
            this.pmp = _data["pmp"];
            this.seuil_stock_alerte = _data["seuil_stock_alerte"];
            this.desiredstock = _data["desiredstock"];
            this.duration = _data["duration"];
            this.fk_default_workstation = _data["fk_default_workstation"];
            this.status_buy = _data["status_buy"];
            this.finished = _data["finished"];
            this.status_batch = _data["status_batch"];
            this.batch_mask = _data["batch_mask"];
            this.customcode = _data["customcode"];
            this.url = _data["url"];
            this.weight = _data["weight"];
            this.weight_units = _data["weight_units"];
            this.length = _data["length"];
            this.length_units = _data["length_units"];
            this.width = _data["width"];
            this.width_units = _data["width_units"];
            this.height = _data["height"];
            this.height_units = _data["height_units"];
            this.surface = _data["surface"];
            this.surface_units = _data["surface_units"];
            this.volume = _data["volume"];
            this.volume_units = _data["volume_units"];
            this.accountancy_code_sell = _data["accountancy_code_sell"];
            this.accountancy_code_sell_intra = _data["accountancy_code_sell_intra"];
            this.accountancy_code_sell_export = _data["accountancy_code_sell_export"];
            this.accountancy_code_buy = _data["accountancy_code_buy"];
            this.accountancy_code_buy_intra = _data["accountancy_code_buy_intra"];
            this.accountancy_code_buy_export = _data["accountancy_code_buy_export"];
            this.barcode = _data["barcode"];
            this.price_autogen = _data["price_autogen"];
            this.mandatory_period = _data["mandatory_period"];
        }
    }

    static fromJS(data: any): ProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["module"] = this.module;
        data["id"] = this.id;
        data["entity"] = this.entity;
        data["ref"] = this.ref;
        data["status"] = this.status;
        data["country_id"] = this.country_id;
        data["country_code"] = this.country_code;
        data["state_id"] = this.state_id;
        data["region_id"] = this.region_id;
        data["note_public"] = this.note_public;
        data["note_private"] = this.note_private;
        data["date_creation"] = this.date_creation;
        data["date_validation"] = this.date_validation;
        data["date_modification"] = this.date_modification;
        data["date_update"] = this.date_update;
        data["user_creation_id"] = this.user_creation_id;
        data["user_valid"] = this.user_valid;
        data["user_validation_id"] = this.user_validation_id;
        data["user_closing_id"] = this.user_closing_id;
        data["user_modification_id"] = this.user_modification_id;
        data["specimen"] = this.specimen;
        data["labelStatus"] = this.labelStatus;
        data["label"] = this.label;
        data["description"] = this.description;
        data["type"] = this.type;
        data["price"] = this.price;
        data["price_formated"] = this.price_formated;
        data["price_ttc"] = this.price_ttc;
        data["price_ttc_formated"] = this.price_ttc_formated;
        data["price_min"] = this.price_min;
        data["price_min_ttc"] = this.price_min_ttc;
        data["price_base_type"] = this.price_base_type;
        data["default_vat_code"] = this.default_vat_code;
        data["tva_tx"] = this.tva_tx;
        data["remise_percent"] = this.remise_percent;
        data["localtax1_tx"] = this.localtax1_tx;
        data["localtax2_tx"] = this.localtax2_tx;
        data["localtax1_type"] = this.localtax1_type;
        data["localtax2_type"] = this.localtax2_type;
        data["pmp"] = this.pmp;
        data["seuil_stock_alerte"] = this.seuil_stock_alerte;
        data["desiredstock"] = this.desiredstock;
        data["duration"] = this.duration;
        data["fk_default_workstation"] = this.fk_default_workstation;
        data["status_buy"] = this.status_buy;
        data["finished"] = this.finished;
        data["status_batch"] = this.status_batch;
        data["batch_mask"] = this.batch_mask;
        data["customcode"] = this.customcode;
        data["url"] = this.url;
        data["weight"] = this.weight;
        data["weight_units"] = this.weight_units;
        data["length"] = this.length;
        data["length_units"] = this.length_units;
        data["width"] = this.width;
        data["width_units"] = this.width_units;
        data["height"] = this.height;
        data["height_units"] = this.height_units;
        data["surface"] = this.surface;
        data["surface_units"] = this.surface_units;
        data["volume"] = this.volume;
        data["volume_units"] = this.volume_units;
        data["accountancy_code_sell"] = this.accountancy_code_sell;
        data["accountancy_code_sell_intra"] = this.accountancy_code_sell_intra;
        data["accountancy_code_sell_export"] = this.accountancy_code_sell_export;
        data["accountancy_code_buy"] = this.accountancy_code_buy;
        data["accountancy_code_buy_intra"] = this.accountancy_code_buy_intra;
        data["accountancy_code_buy_export"] = this.accountancy_code_buy_export;
        data["barcode"] = this.barcode;
        data["price_autogen"] = this.price_autogen;
        data["mandatory_period"] = this.mandatory_period;
        return data;
    }
}

export interface IProductDto {
    module?: string | undefined;
    id?: number;
    entity?: string | undefined;
    ref?: string | undefined;
    status?: string | undefined;
    country_id?: string | undefined;
    country_code?: string | undefined;
    state_id?: string | undefined;
    region_id?: string | undefined;
    note_public?: string | undefined;
    note_private?: string | undefined;
    date_creation?: string | undefined;
    date_validation?: string | undefined;
    date_modification?: string | undefined;
    date_update?: string | undefined;
    user_creation_id?: number | undefined;
    user_valid?: number | undefined;
    user_validation_id?: number | undefined;
    user_closing_id?: number | undefined;
    user_modification_id?: number | undefined;
    specimen?: number | undefined;
    labelStatus?: string | undefined;
    label?: string | undefined;
    description?: string | undefined;
    type?: string | undefined;
    price?: string | undefined;
    price_formated?: string | undefined;
    price_ttc?: string | undefined;
    price_ttc_formated?: string | undefined;
    price_min?: string | undefined;
    price_min_ttc?: string | undefined;
    price_base_type?: string | undefined;
    default_vat_code?: string | undefined;
    tva_tx?: string | undefined;
    remise_percent?: string | undefined;
    localtax1_tx?: string | undefined;
    localtax2_tx?: string | undefined;
    localtax1_type?: string | undefined;
    localtax2_type?: string | undefined;
    pmp?: string | undefined;
    seuil_stock_alerte?: string | undefined;
    desiredstock?: string | undefined;
    duration?: string | undefined;
    fk_default_workstation?: number | undefined;
    status_buy?: string | undefined;
    finished?: string | undefined;
    status_batch?: string | undefined;
    batch_mask?: string | undefined;
    customcode?: string | undefined;
    url?: string | undefined;
    weight?: string | undefined;
    weight_units?: string | undefined;
    length?: string | undefined;
    length_units?: string | undefined;
    width?: string | undefined;
    width_units?: string | undefined;
    height?: string | undefined;
    height_units?: string | undefined;
    surface?: string | undefined;
    surface_units?: string | undefined;
    volume?: string | undefined;
    volume_units?: string | undefined;
    accountancy_code_sell?: string | undefined;
    accountancy_code_sell_intra?: string | undefined;
    accountancy_code_sell_export?: string | undefined;
    accountancy_code_buy?: string | undefined;
    accountancy_code_buy_intra?: string | undefined;
    accountancy_code_buy_export?: string | undefined;
    barcode?: string | undefined;
    price_autogen?: string | undefined;
    mandatory_period?: string | undefined;
}

export class ProjectDto implements IProjectDto {
    id?: number;
    ref?: string | undefined;
    fk_project?: string | undefined;
    title?: string | undefined;
    socid?: number | undefined;
    description?: string | undefined;
    public?: string | undefined;
    opp_amount?: string | undefined;
    budget_amount?: string | undefined;
    date_c?: number | undefined;
    date_start?: number | undefined;
    date_end?: number | undefined;
    date_start_event?: number | undefined;
    date_end_event?: number | undefined;
    location?: string | undefined;
    statut?: number | undefined;
    opp_status?: string | undefined;
    opp_percent?: string | undefined;
    usage_opportunity?: number | undefined;
    usage_task?: number | undefined;
    usage_bill_time?: number | undefined;
    usage_organize_event?: number | undefined;

    constructor(data?: IProjectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.ref = _data["ref"];
            this.fk_project = _data["fk_project"];
            this.title = _data["title"];
            this.socid = _data["socid"];
            this.description = _data["description"];
            this.public = _data["public"];
            this.opp_amount = _data["opp_amount"];
            this.budget_amount = _data["budget_amount"];
            this.date_c = _data["date_c"];
            this.date_start = _data["date_start"];
            this.date_end = _data["date_end"];
            this.date_start_event = _data["date_start_event"];
            this.date_end_event = _data["date_end_event"];
            this.location = _data["location"];
            this.statut = _data["statut"];
            this.opp_status = _data["opp_status"];
            this.opp_percent = _data["opp_percent"];
            this.usage_opportunity = _data["usage_opportunity"];
            this.usage_task = _data["usage_task"];
            this.usage_bill_time = _data["usage_bill_time"];
            this.usage_organize_event = _data["usage_organize_event"];
        }
    }

    static fromJS(data: any): ProjectDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["ref"] = this.ref;
        data["fk_project"] = this.fk_project;
        data["title"] = this.title;
        data["socid"] = this.socid;
        data["description"] = this.description;
        data["public"] = this.public;
        data["opp_amount"] = this.opp_amount;
        data["budget_amount"] = this.budget_amount;
        data["date_c"] = this.date_c;
        data["date_start"] = this.date_start;
        data["date_end"] = this.date_end;
        data["date_start_event"] = this.date_start_event;
        data["date_end_event"] = this.date_end_event;
        data["location"] = this.location;
        data["statut"] = this.statut;
        data["opp_status"] = this.opp_status;
        data["opp_percent"] = this.opp_percent;
        data["usage_opportunity"] = this.usage_opportunity;
        data["usage_task"] = this.usage_task;
        data["usage_bill_time"] = this.usage_bill_time;
        data["usage_organize_event"] = this.usage_organize_event;
        return data;
    }
}

export interface IProjectDto {
    id?: number;
    ref?: string | undefined;
    fk_project?: string | undefined;
    title?: string | undefined;
    socid?: number | undefined;
    description?: string | undefined;
    public?: string | undefined;
    opp_amount?: string | undefined;
    budget_amount?: string | undefined;
    date_c?: number | undefined;
    date_start?: number | undefined;
    date_end?: number | undefined;
    date_start_event?: number | undefined;
    date_end_event?: number | undefined;
    location?: string | undefined;
    statut?: number | undefined;
    opp_status?: string | undefined;
    opp_percent?: string | undefined;
    usage_opportunity?: number | undefined;
    usage_task?: number | undefined;
    usage_bill_time?: number | undefined;
    usage_organize_event?: number | undefined;
}

export class ProposalDto implements IProposalDto {
    module?: string | undefined;
    id?: string | undefined;
    entity?: string | undefined;
    contacts_ids?: string[] | undefined;
    fk_project?: string | undefined;
    contact_id?: string | undefined;
    ref?: string | undefined;
    ref_ext?: string | undefined;
    statut?: number | undefined;
    status?: number | undefined;
    country_id?: string | undefined;
    country_code?: string | undefined;
    state_id?: string | undefined;
    region_id?: string | undefined;
    mode_reglement_id?: string | undefined;
    cond_reglement_id?: string | undefined;
    demand_reason_id?: string | undefined;
    transport_mode_id?: string | undefined;
    shipping_method_id?: string | undefined;
    shipping_method?: string | undefined;
    multicurrency_code?: string | undefined;
    multicurrency_tx?: string | undefined;
    model_pdf?: string | undefined;
    last_main_doc?: string | undefined;
    note_public?: string | undefined;
    note_private?: string | undefined;
    total_ht?: string | undefined;
    total_tva?: string | undefined;
    total_localtax1?: string | undefined;
    ttal_localtax2?: string | undefined;
    total_ttc?: string | undefined;
    date_creation?: number | undefined;
    date_modification?: number | undefined;
    date_update?: number | undefined;
    date_cloture?: number | undefined;
    user_creation_id?: number | undefined;
    user_validation_id?: number | undefined;
    user_closing_id?: number | undefined;
    user_modification?: number | undefined;
    user_modification_id?: number | undefined;
    specimen?: number | undefined;
    code?: string | undefined;
    socid?: string | undefined;
    contactid?: any | undefined;
    ref_client?: string | undefined;
    datec?: number | undefined;
    datev?: string | undefined;
    date_signature?: string | undefined;
    user_signature?: string | undefined;
    date?: number | undefined;
    datep?: number | undefined;
    date_livraison?: number | undefined;
    delivery_date?: number | undefined;
    fin_validite?: number | undefined;
    user_author_id?: string | undefined;
    user_valid_id?: string | undefined;
    user_close_id?: string | undefined;
    price?: string | undefined;
    total?: string | undefined;
    cond_reglement_code?: string | undefined;
    cond_reglement_doc?: string | undefined;
    mode_reglement_code?: string | undefined;
    remise_percent?: string | undefined;
    remise?: string | undefined;
    remise_absolue?: string | undefined;
    fk_address?: string | undefined;
    availability_id?: string | undefined;
    availability_code?: string | undefined;
    duree_validite?: number | undefined;
    demand_reason_code?: string | undefined;
    fk_multicurrency?: string | undefined;
    multicurrency_total_ht?: string | undefined;
    multicurrency_total_tva?: string | undefined;
    multicurrency_total_ttc?: string | undefined;
    fk_incoterms?: string | undefined;
    location_incoterms?: string | undefined;
    ref_customer?: string | undefined;
    availability?: string | undefined;
    demand_reason?: string | undefined;
    brouillon?: number | undefined;

    constructor(data?: IProposalDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.module = _data["module"];
            this.id = _data["id"];
            this.entity = _data["entity"];
            if (Array.isArray(_data["contacts_ids"])) {
                this.contacts_ids = [] as any;
                for (let item of _data["contacts_ids"])
                    this.contacts_ids!.push(item);
            }
            this.fk_project = _data["fk_project"];
            this.contact_id = _data["contact_id"];
            this.ref = _data["ref"];
            this.ref_ext = _data["ref_ext"];
            this.statut = _data["statut"];
            this.status = _data["status"];
            this.country_id = _data["country_id"];
            this.country_code = _data["country_code"];
            this.state_id = _data["state_id"];
            this.region_id = _data["region_id"];
            this.mode_reglement_id = _data["mode_reglement_id"];
            this.cond_reglement_id = _data["cond_reglement_id"];
            this.demand_reason_id = _data["demand_reason_id"];
            this.transport_mode_id = _data["transport_mode_id"];
            this.shipping_method_id = _data["shipping_method_id"];
            this.shipping_method = _data["shipping_method"];
            this.multicurrency_code = _data["multicurrency_code"];
            this.multicurrency_tx = _data["multicurrency_tx"];
            this.model_pdf = _data["model_pdf"];
            this.last_main_doc = _data["last_main_doc"];
            this.note_public = _data["note_public"];
            this.note_private = _data["note_private"];
            this.total_ht = _data["total_ht"];
            this.total_tva = _data["total_tva"];
            this.total_localtax1 = _data["total_localtax1"];
            this.ttal_localtax2 = _data["ttal_localtax2"];
            this.total_ttc = _data["total_ttc"];
            this.date_creation = _data["date_creation"];
            this.date_modification = _data["date_modification"];
            this.date_update = _data["date_update"];
            this.date_cloture = _data["date_cloture"];
            this.user_creation_id = _data["user_creation_id"];
            this.user_validation_id = _data["user_validation_id"];
            this.user_closing_id = _data["user_closing_id"];
            this.user_modification = _data["user_modification"];
            this.user_modification_id = _data["user_modification_id"];
            this.specimen = _data["specimen"];
            this.code = _data["code"];
            this.socid = _data["socid"];
            this.contactid = _data["contactid"];
            this.ref_client = _data["ref_client"];
            this.datec = _data["datec"];
            this.datev = _data["datev"];
            this.date_signature = _data["date_signature"];
            this.user_signature = _data["user_signature"];
            this.date = _data["date"];
            this.datep = _data["datep"];
            this.date_livraison = _data["date_livraison"];
            this.delivery_date = _data["delivery_date"];
            this.fin_validite = _data["fin_validite"];
            this.user_author_id = _data["user_author_id"];
            this.user_valid_id = _data["user_valid_id"];
            this.user_close_id = _data["user_close_id"];
            this.price = _data["price"];
            this.total = _data["total"];
            this.cond_reglement_code = _data["cond_reglement_code"];
            this.cond_reglement_doc = _data["cond_reglement_doc"];
            this.mode_reglement_code = _data["mode_reglement_code"];
            this.remise_percent = _data["remise_percent"];
            this.remise = _data["remise"];
            this.remise_absolue = _data["remise_absolue"];
            this.fk_address = _data["fk_address"];
            this.availability_id = _data["availability_id"];
            this.availability_code = _data["availability_code"];
            this.duree_validite = _data["duree_validite"];
            this.demand_reason_code = _data["demand_reason_code"];
            this.fk_multicurrency = _data["fk_multicurrency"];
            this.multicurrency_total_ht = _data["multicurrency_total_ht"];
            this.multicurrency_total_tva = _data["multicurrency_total_tva"];
            this.multicurrency_total_ttc = _data["multicurrency_total_ttc"];
            this.fk_incoterms = _data["fk_incoterms"];
            this.location_incoterms = _data["location_incoterms"];
            this.ref_customer = _data["ref_customer"];
            this.availability = _data["availability"];
            this.demand_reason = _data["demand_reason"];
            this.brouillon = _data["brouillon"];
        }
    }

    static fromJS(data: any): ProposalDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProposalDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["module"] = this.module;
        data["id"] = this.id;
        data["entity"] = this.entity;
        if (Array.isArray(this.contacts_ids)) {
            data["contacts_ids"] = [];
            for (let item of this.contacts_ids)
                data["contacts_ids"].push(item);
        }
        data["fk_project"] = this.fk_project;
        data["contact_id"] = this.contact_id;
        data["ref"] = this.ref;
        data["ref_ext"] = this.ref_ext;
        data["statut"] = this.statut;
        data["status"] = this.status;
        data["country_id"] = this.country_id;
        data["country_code"] = this.country_code;
        data["state_id"] = this.state_id;
        data["region_id"] = this.region_id;
        data["mode_reglement_id"] = this.mode_reglement_id;
        data["cond_reglement_id"] = this.cond_reglement_id;
        data["demand_reason_id"] = this.demand_reason_id;
        data["transport_mode_id"] = this.transport_mode_id;
        data["shipping_method_id"] = this.shipping_method_id;
        data["shipping_method"] = this.shipping_method;
        data["multicurrency_code"] = this.multicurrency_code;
        data["multicurrency_tx"] = this.multicurrency_tx;
        data["model_pdf"] = this.model_pdf;
        data["last_main_doc"] = this.last_main_doc;
        data["note_public"] = this.note_public;
        data["note_private"] = this.note_private;
        data["total_ht"] = this.total_ht;
        data["total_tva"] = this.total_tva;
        data["total_localtax1"] = this.total_localtax1;
        data["ttal_localtax2"] = this.ttal_localtax2;
        data["total_ttc"] = this.total_ttc;
        data["date_creation"] = this.date_creation;
        data["date_modification"] = this.date_modification;
        data["date_update"] = this.date_update;
        data["date_cloture"] = this.date_cloture;
        data["user_creation_id"] = this.user_creation_id;
        data["user_validation_id"] = this.user_validation_id;
        data["user_closing_id"] = this.user_closing_id;
        data["user_modification"] = this.user_modification;
        data["user_modification_id"] = this.user_modification_id;
        data["specimen"] = this.specimen;
        data["code"] = this.code;
        data["socid"] = this.socid;
        data["contactid"] = this.contactid;
        data["ref_client"] = this.ref_client;
        data["datec"] = this.datec;
        data["datev"] = this.datev;
        data["date_signature"] = this.date_signature;
        data["user_signature"] = this.user_signature;
        data["date"] = this.date;
        data["datep"] = this.datep;
        data["date_livraison"] = this.date_livraison;
        data["delivery_date"] = this.delivery_date;
        data["fin_validite"] = this.fin_validite;
        data["user_author_id"] = this.user_author_id;
        data["user_valid_id"] = this.user_valid_id;
        data["user_close_id"] = this.user_close_id;
        data["price"] = this.price;
        data["total"] = this.total;
        data["cond_reglement_code"] = this.cond_reglement_code;
        data["cond_reglement_doc"] = this.cond_reglement_doc;
        data["mode_reglement_code"] = this.mode_reglement_code;
        data["remise_percent"] = this.remise_percent;
        data["remise"] = this.remise;
        data["remise_absolue"] = this.remise_absolue;
        data["fk_address"] = this.fk_address;
        data["availability_id"] = this.availability_id;
        data["availability_code"] = this.availability_code;
        data["duree_validite"] = this.duree_validite;
        data["demand_reason_code"] = this.demand_reason_code;
        data["fk_multicurrency"] = this.fk_multicurrency;
        data["multicurrency_total_ht"] = this.multicurrency_total_ht;
        data["multicurrency_total_tva"] = this.multicurrency_total_tva;
        data["multicurrency_total_ttc"] = this.multicurrency_total_ttc;
        data["fk_incoterms"] = this.fk_incoterms;
        data["location_incoterms"] = this.location_incoterms;
        data["ref_customer"] = this.ref_customer;
        data["availability"] = this.availability;
        data["demand_reason"] = this.demand_reason;
        data["brouillon"] = this.brouillon;
        return data;
    }
}

export interface IProposalDto {
    module?: string | undefined;
    id?: string | undefined;
    entity?: string | undefined;
    contacts_ids?: string[] | undefined;
    fk_project?: string | undefined;
    contact_id?: string | undefined;
    ref?: string | undefined;
    ref_ext?: string | undefined;
    statut?: number | undefined;
    status?: number | undefined;
    country_id?: string | undefined;
    country_code?: string | undefined;
    state_id?: string | undefined;
    region_id?: string | undefined;
    mode_reglement_id?: string | undefined;
    cond_reglement_id?: string | undefined;
    demand_reason_id?: string | undefined;
    transport_mode_id?: string | undefined;
    shipping_method_id?: string | undefined;
    shipping_method?: string | undefined;
    multicurrency_code?: string | undefined;
    multicurrency_tx?: string | undefined;
    model_pdf?: string | undefined;
    last_main_doc?: string | undefined;
    note_public?: string | undefined;
    note_private?: string | undefined;
    total_ht?: string | undefined;
    total_tva?: string | undefined;
    total_localtax1?: string | undefined;
    ttal_localtax2?: string | undefined;
    total_ttc?: string | undefined;
    date_creation?: number | undefined;
    date_modification?: number | undefined;
    date_update?: number | undefined;
    date_cloture?: number | undefined;
    user_creation_id?: number | undefined;
    user_validation_id?: number | undefined;
    user_closing_id?: number | undefined;
    user_modification?: number | undefined;
    user_modification_id?: number | undefined;
    specimen?: number | undefined;
    code?: string | undefined;
    socid?: string | undefined;
    contactid?: any | undefined;
    ref_client?: string | undefined;
    datec?: number | undefined;
    datev?: string | undefined;
    date_signature?: string | undefined;
    user_signature?: string | undefined;
    date?: number | undefined;
    datep?: number | undefined;
    date_livraison?: number | undefined;
    delivery_date?: number | undefined;
    fin_validite?: number | undefined;
    user_author_id?: string | undefined;
    user_valid_id?: string | undefined;
    user_close_id?: string | undefined;
    price?: string | undefined;
    total?: string | undefined;
    cond_reglement_code?: string | undefined;
    cond_reglement_doc?: string | undefined;
    mode_reglement_code?: string | undefined;
    remise_percent?: string | undefined;
    remise?: string | undefined;
    remise_absolue?: string | undefined;
    fk_address?: string | undefined;
    availability_id?: string | undefined;
    availability_code?: string | undefined;
    duree_validite?: number | undefined;
    demand_reason_code?: string | undefined;
    fk_multicurrency?: string | undefined;
    multicurrency_total_ht?: string | undefined;
    multicurrency_total_tva?: string | undefined;
    multicurrency_total_ttc?: string | undefined;
    fk_incoterms?: string | undefined;
    location_incoterms?: string | undefined;
    ref_customer?: string | undefined;
    availability?: string | undefined;
    demand_reason?: string | undefined;
    brouillon?: number | undefined;
}

export class RegionDto implements IRegionDto {
    id?: number;
    code_region?: number;
    fk_pays?: number;
    name?: string | undefined;
    cheflieu?: string | undefined;
    active?: number;

    constructor(data?: IRegionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code_region = _data["code_region"];
            this.fk_pays = _data["fk_pays"];
            this.name = _data["name"];
            this.cheflieu = _data["cheflieu"];
            this.active = _data["active"];
        }
    }

    static fromJS(data: any): RegionDto {
        data = typeof data === 'object' ? data : {};
        let result = new RegionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code_region"] = this.code_region;
        data["fk_pays"] = this.fk_pays;
        data["name"] = this.name;
        data["cheflieu"] = this.cheflieu;
        data["active"] = this.active;
        return data;
    }
}

export interface IRegionDto {
    id?: number;
    code_region?: number;
    fk_pays?: number;
    name?: string | undefined;
    cheflieu?: string | undefined;
    active?: number;
}

export class ShippingMethodDto implements IShippingMethodDto {
    id?: number;
    code?: string | undefined;
    label?: string | undefined;
    description?: string | undefined;
    tracking?: string | undefined;
    module?: string | undefined;

    constructor(data?: IShippingMethodDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.label = _data["label"];
            this.description = _data["description"];
            this.tracking = _data["tracking"];
            this.module = _data["module"];
        }
    }

    static fromJS(data: any): ShippingMethodDto {
        data = typeof data === 'object' ? data : {};
        let result = new ShippingMethodDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["label"] = this.label;
        data["description"] = this.description;
        data["tracking"] = this.tracking;
        data["module"] = this.module;
        return data;
    }
}

export interface IShippingMethodDto {
    id?: number;
    code?: string | undefined;
    label?: string | undefined;
    description?: string | undefined;
    tracking?: string | undefined;
    module?: string | undefined;
}

export class SocialNetworkDto implements ISocialNetworkDto {
    rowid?: number;
    entity?: number;
    code?: string | undefined;
    label?: string | undefined;
    url?: string | undefined;
    icon?: string | undefined;
    active?: string | undefined;

    constructor(data?: ISocialNetworkDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rowid = _data["rowid"];
            this.entity = _data["entity"];
            this.code = _data["code"];
            this.label = _data["label"];
            this.url = _data["url"];
            this.icon = _data["icon"];
            this.active = _data["active"];
        }
    }

    static fromJS(data: any): SocialNetworkDto {
        data = typeof data === 'object' ? data : {};
        let result = new SocialNetworkDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rowid"] = this.rowid;
        data["entity"] = this.entity;
        data["code"] = this.code;
        data["label"] = this.label;
        data["url"] = this.url;
        data["icon"] = this.icon;
        data["active"] = this.active;
        return data;
    }
}

export interface ISocialNetworkDto {
    rowid?: number;
    entity?: number;
    code?: string | undefined;
    label?: string | undefined;
    url?: string | undefined;
    icon?: string | undefined;
    active?: string | undefined;
}

export class StaffDto implements IStaffDto {
    id?: number;
    code?: string | undefined;
    libelle?: string | undefined;
    active?: number;
    module?: string | undefined;

    constructor(data?: IStaffDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.libelle = _data["libelle"];
            this.active = _data["active"];
            this.module = _data["module"];
        }
    }

    static fromJS(data: any): StaffDto {
        data = typeof data === 'object' ? data : {};
        let result = new StaffDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["libelle"] = this.libelle;
        data["active"] = this.active;
        data["module"] = this.module;
        return data;
    }
}

export interface IStaffDto {
    id?: number;
    code?: string | undefined;
    libelle?: string | undefined;
    active?: number;
    module?: string | undefined;
}

export class StateDto implements IStateDto {
    id?: number;
    rowid?: number | undefined;
    code_departement?: string | undefined;
    code?: string | undefined;
    name?: string | undefined;
    nom?: string | undefined;
    label?: string | undefined;
    active?: number;

    constructor(data?: IStateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.rowid = _data["rowid"];
            this.code_departement = _data["code_departement"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.nom = _data["nom"];
            this.label = _data["label"];
            this.active = _data["active"];
        }
    }

    static fromJS(data: any): StateDto {
        data = typeof data === 'object' ? data : {};
        let result = new StateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["rowid"] = this.rowid;
        data["code_departement"] = this.code_departement;
        data["code"] = this.code;
        data["name"] = this.name;
        data["nom"] = this.nom;
        data["label"] = this.label;
        data["active"] = this.active;
        return data;
    }
}

export interface IStateDto {
    id?: number;
    rowid?: number | undefined;
    code_departement?: string | undefined;
    code?: string | undefined;
    name?: string | undefined;
    nom?: string | undefined;
    label?: string | undefined;
    active?: number;
}

export class StatusDto implements IStatusDto {
    code?: string | undefined;
    dolibarr_version?: string | undefined;
    access_locked?: string | undefined;

    constructor(data?: IStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.dolibarr_version = _data["dolibarr_version"];
            this.access_locked = _data["access_locked"];
        }
    }

    static fromJS(data: any): StatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new StatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["dolibarr_version"] = this.dolibarr_version;
        data["access_locked"] = this.access_locked;
        return data;
    }
}

export interface IStatusDto {
    code?: string | undefined;
    dolibarr_version?: string | undefined;
    access_locked?: string | undefined;
}

export class StatusResponseDto implements IStatusResponseDto {
    success?: StatusDto;

    constructor(data?: IStatusResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] ? StatusDto.fromJS(_data["success"]) : <any>undefined;
        }
    }

    static fromJS(data: any): StatusResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new StatusResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success ? this.success.toJSON() : <any>undefined;
        return data;
    }
}

export interface IStatusResponseDto {
    success?: StatusDto;
}

export class TaskDto implements ITaskDto {
    id?: number;
    fk_project?: string | undefined;
    entity?: string | undefined;
    ref?: string | undefined;
    label?: string | undefined;
    description?: string | undefined;
    planned_workload?: string | undefined;
    fk_task_parent?: string | undefined;
    date_c?: number | undefined;
    date_start?: number | undefined;
    date_end?: number | undefined;
    progress?: string | undefined;
    budget_amount?: string | undefined;

    constructor(data?: ITaskDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fk_project = _data["fk_project"];
            this.entity = _data["entity"];
            this.ref = _data["ref"];
            this.label = _data["label"];
            this.description = _data["description"];
            this.planned_workload = _data["planned_workload"];
            this.fk_task_parent = _data["fk_task_parent"];
            this.date_c = _data["date_c"];
            this.date_start = _data["date_start"];
            this.date_end = _data["date_end"];
            this.progress = _data["progress"];
            this.budget_amount = _data["budget_amount"];
        }
    }

    static fromJS(data: any): TaskDto {
        data = typeof data === 'object' ? data : {};
        let result = new TaskDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fk_project"] = this.fk_project;
        data["entity"] = this.entity;
        data["ref"] = this.ref;
        data["label"] = this.label;
        data["description"] = this.description;
        data["planned_workload"] = this.planned_workload;
        data["fk_task_parent"] = this.fk_task_parent;
        data["date_c"] = this.date_c;
        data["date_start"] = this.date_start;
        data["date_end"] = this.date_end;
        data["progress"] = this.progress;
        data["budget_amount"] = this.budget_amount;
        return data;
    }
}

export interface ITaskDto {
    id?: number;
    fk_project?: string | undefined;
    entity?: string | undefined;
    ref?: string | undefined;
    label?: string | undefined;
    description?: string | undefined;
    planned_workload?: string | undefined;
    fk_task_parent?: string | undefined;
    date_c?: number | undefined;
    date_start?: number | undefined;
    date_end?: number | undefined;
    progress?: string | undefined;
    budget_amount?: string | undefined;
}

export class ThirdPartyDto implements IThirdPartyDto {
    module?: string | undefined;
    id?: number | undefined;
    entity?: string | undefined;
    ref?: string | undefined;
    status?: string | undefined;
    country_code?: string | undefined;
    country_id?: number | undefined;
    name?: string | undefined;
    name_alias?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;
    skype?: string | undefined;
    twitter?: string | undefined;
    facebook?: string | undefined;
    linkedin?: string | undefined;
    url?: string | undefined;
    barcode?: string | undefined;
    idProf1?: string | undefined;
    idProf2?: string | undefined;
    idProf3?: string | undefined;
    idProf4?: string | undefined;
    idProf5?: string | undefined;
    idProf6?: string | undefined;
    address?: string | undefined;
    zip?: string | undefined;
    town?: string | undefined;

    constructor(data?: IThirdPartyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.module = _data["module"];
            this.id = _data["id"];
            this.entity = _data["entity"];
            this.ref = _data["ref"];
            this.status = _data["status"];
            this.country_code = _data["country_code"];
            this.country_id = _data["country_id"];
            this.name = _data["name"];
            this.name_alias = _data["name_alias"];
            this.phone = _data["phone"];
            this.email = _data["email"];
            this.skype = _data["skype"];
            this.twitter = _data["twitter"];
            this.facebook = _data["facebook"];
            this.linkedin = _data["linkedin"];
            this.url = _data["url"];
            this.barcode = _data["barcode"];
            this.idProf1 = _data["idProf1"];
            this.idProf2 = _data["idProf2"];
            this.idProf3 = _data["idProf3"];
            this.idProf4 = _data["idProf4"];
            this.idProf5 = _data["idProf5"];
            this.idProf6 = _data["idProf6"];
            this.address = _data["address"];
            this.zip = _data["zip"];
            this.town = _data["town"];
        }
    }

    static fromJS(data: any): ThirdPartyDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThirdPartyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["module"] = this.module;
        data["id"] = this.id;
        data["entity"] = this.entity;
        data["ref"] = this.ref;
        data["status"] = this.status;
        data["country_code"] = this.country_code;
        data["country_id"] = this.country_id;
        data["name"] = this.name;
        data["name_alias"] = this.name_alias;
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["skype"] = this.skype;
        data["twitter"] = this.twitter;
        data["facebook"] = this.facebook;
        data["linkedin"] = this.linkedin;
        data["url"] = this.url;
        data["barcode"] = this.barcode;
        data["idProf1"] = this.idProf1;
        data["idProf2"] = this.idProf2;
        data["idProf3"] = this.idProf3;
        data["idProf4"] = this.idProf4;
        data["idProf5"] = this.idProf5;
        data["idProf6"] = this.idProf6;
        data["address"] = this.address;
        data["zip"] = this.zip;
        data["town"] = this.town;
        return data;
    }
}

export interface IThirdPartyDto {
    module?: string | undefined;
    id?: number | undefined;
    entity?: string | undefined;
    ref?: string | undefined;
    status?: string | undefined;
    country_code?: string | undefined;
    country_id?: number | undefined;
    name?: string | undefined;
    name_alias?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;
    skype?: string | undefined;
    twitter?: string | undefined;
    facebook?: string | undefined;
    linkedin?: string | undefined;
    url?: string | undefined;
    barcode?: string | undefined;
    idProf1?: string | undefined;
    idProf2?: string | undefined;
    idProf3?: string | undefined;
    idProf4?: string | undefined;
    idProf5?: string | undefined;
    idProf6?: string | undefined;
    address?: string | undefined;
    zip?: string | undefined;
    town?: string | undefined;
}

export class TicketCategoryDto implements ITicketCategoryDto {
    rowid?: number;
    code?: string | undefined;
    pos?: string | undefined;
    label?: string | undefined;
    useDefault?: string | undefined;
    description?: string | undefined;

    constructor(data?: ITicketCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rowid = _data["rowid"];
            this.code = _data["code"];
            this.pos = _data["pos"];
            this.label = _data["label"];
            this.useDefault = _data["useDefault"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): TicketCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rowid"] = this.rowid;
        data["code"] = this.code;
        data["pos"] = this.pos;
        data["label"] = this.label;
        data["useDefault"] = this.useDefault;
        data["description"] = this.description;
        return data;
    }
}

export interface ITicketCategoryDto {
    rowid?: number;
    code?: string | undefined;
    pos?: string | undefined;
    label?: string | undefined;
    useDefault?: string | undefined;
    description?: string | undefined;
}

export class TicketDto implements ITicketDto {
    module?: string | undefined;
    id?: number | undefined;
    entity?: string | undefined;
    import_key?: string | undefined;
    fk_project?: string | undefined;
    ref?: string | undefined;
    status?: string | undefined;
    date_creation?: number | undefined;
    date_validation?: string | undefined;
    date_modification?: number | undefined;
    date_update?: number | undefined;
    specimen?: number | undefined;
    track_id?: string | undefined;
    fk_user_create?: string | undefined;
    fk_user_assign?: number | undefined;
    subject: string | undefined;
    message?: string | undefined;
    fk_statut?: string | undefined;
    progress?: string | undefined;
    type_code?: string | undefined;
    category_code?: string | undefined;
    severity_code?: string | undefined;
    type_label?: string | undefined;
    category_label?: string | undefined;
    severity_label?: string | undefined;
    date_close?: string | undefined;
    socid?: number | undefined;

    constructor(data?: ITicketDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.module = _data["module"];
            this.id = _data["id"];
            this.entity = _data["entity"];
            this.import_key = _data["import_key"];
            this.fk_project = _data["fk_project"];
            this.ref = _data["ref"];
            this.status = _data["status"];
            this.date_creation = _data["date_creation"];
            this.date_validation = _data["date_validation"];
            this.date_modification = _data["date_modification"];
            this.date_update = _data["date_update"];
            this.specimen = _data["specimen"];
            this.track_id = _data["track_id"];
            this.fk_user_create = _data["fk_user_create"];
            this.fk_user_assign = _data["fk_user_assign"];
            this.subject = _data["subject"];
            this.message = _data["message"];
            this.fk_statut = _data["fk_statut"];
            this.progress = _data["progress"];
            this.type_code = _data["type_code"];
            this.category_code = _data["category_code"];
            this.severity_code = _data["severity_code"];
            this.type_label = _data["type_label"];
            this.category_label = _data["category_label"];
            this.severity_label = _data["severity_label"];
            this.date_close = _data["date_close"];
            this.socid = _data["socid"];
        }
    }

    static fromJS(data: any): TicketDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["module"] = this.module;
        data["id"] = this.id;
        data["entity"] = this.entity;
        data["import_key"] = this.import_key;
        data["fk_project"] = this.fk_project;
        data["ref"] = this.ref;
        data["status"] = this.status;
        data["date_creation"] = this.date_creation;
        data["date_validation"] = this.date_validation;
        data["date_modification"] = this.date_modification;
        data["date_update"] = this.date_update;
        data["specimen"] = this.specimen;
        data["track_id"] = this.track_id;
        data["fk_user_create"] = this.fk_user_create;
        data["fk_user_assign"] = this.fk_user_assign;
        data["subject"] = this.subject;
        data["message"] = this.message;
        data["fk_statut"] = this.fk_statut;
        data["progress"] = this.progress;
        data["type_code"] = this.type_code;
        data["category_code"] = this.category_code;
        data["severity_code"] = this.severity_code;
        data["type_label"] = this.type_label;
        data["category_label"] = this.category_label;
        data["severity_label"] = this.severity_label;
        data["date_close"] = this.date_close;
        data["socid"] = this.socid;
        return data;
    }
}

export interface ITicketDto {
    module?: string | undefined;
    id?: number | undefined;
    entity?: string | undefined;
    import_key?: string | undefined;
    fk_project?: string | undefined;
    ref?: string | undefined;
    status?: string | undefined;
    date_creation?: number | undefined;
    date_validation?: string | undefined;
    date_modification?: number | undefined;
    date_update?: number | undefined;
    specimen?: number | undefined;
    track_id?: string | undefined;
    fk_user_create?: string | undefined;
    fk_user_assign?: number | undefined;
    subject: string | undefined;
    message?: string | undefined;
    fk_statut?: string | undefined;
    progress?: string | undefined;
    type_code?: string | undefined;
    category_code?: string | undefined;
    severity_code?: string | undefined;
    type_label?: string | undefined;
    category_label?: string | undefined;
    severity_label?: string | undefined;
    date_close?: string | undefined;
    socid?: number | undefined;
}

export class TicketSeveritiesDto implements ITicketSeveritiesDto {
    rowid?: number;
    code?: string | undefined;
    pos?: string | undefined;
    label?: string | undefined;
    use_default?: string | undefined;
    color?: string | undefined;
    description?: string | undefined;

    constructor(data?: ITicketSeveritiesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rowid = _data["rowid"];
            this.code = _data["code"];
            this.pos = _data["pos"];
            this.label = _data["label"];
            this.use_default = _data["use_default"];
            this.color = _data["color"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): TicketSeveritiesDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketSeveritiesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rowid"] = this.rowid;
        data["code"] = this.code;
        data["pos"] = this.pos;
        data["label"] = this.label;
        data["use_default"] = this.use_default;
        data["color"] = this.color;
        data["description"] = this.description;
        return data;
    }
}

export interface ITicketSeveritiesDto {
    rowid?: number;
    code?: string | undefined;
    pos?: string | undefined;
    label?: string | undefined;
    use_default?: string | undefined;
    color?: string | undefined;
    description?: string | undefined;
}

export class TicketTypeDto implements ITicketTypeDto {
    rowid?: number;
    code?: string | undefined;
    pos?: string | undefined;
    label?: string | undefined;
    use_default?: number;
    description?: string | undefined;

    constructor(data?: ITicketTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rowid = _data["rowid"];
            this.code = _data["code"];
            this.pos = _data["pos"];
            this.label = _data["label"];
            this.use_default = _data["use_default"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): TicketTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rowid"] = this.rowid;
        data["code"] = this.code;
        data["pos"] = this.pos;
        data["label"] = this.label;
        data["use_default"] = this.use_default;
        data["description"] = this.description;
        return data;
    }
}

export interface ITicketTypeDto {
    rowid?: number;
    code?: string | undefined;
    pos?: string | undefined;
    label?: string | undefined;
    use_default?: number;
    description?: string | undefined;
}

export class TownDto implements ITownDto {

    constructor(data?: ITownDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): TownDto {
        data = typeof data === 'object' ? data : {};
        let result = new TownDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface ITownDto {
}

export class UnitDto implements IUnitDto {
    rowid?: number;
    code?: string | undefined;
    label?: string | undefined;
    short_label?: string | undefined;
    active?: number;
    scale?: number;
    unit_type?: string | undefined;

    constructor(data?: IUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rowid = _data["rowid"];
            this.code = _data["code"];
            this.label = _data["label"];
            this.short_label = _data["short_label"];
            this.active = _data["active"];
            this.scale = _data["scale"];
            this.unit_type = _data["unit_type"];
        }
    }

    static fromJS(data: any): UnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new UnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rowid"] = this.rowid;
        data["code"] = this.code;
        data["label"] = this.label;
        data["short_label"] = this.short_label;
        data["active"] = this.active;
        data["scale"] = this.scale;
        data["unit_type"] = this.unit_type;
        return data;
    }
}

export interface IUnitDto {
    rowid?: number;
    code?: string | undefined;
    label?: string | undefined;
    short_label?: string | undefined;
    active?: number;
    scale?: number;
    unit_type?: string | undefined;
}

export class UserDto implements IUserDto {
    module?: string | undefined;
    id?: number;
    entity?: string | undefined;
    civility_code?: string | undefined;
    lastname?: string | undefined;
    firstname?: string | undefined;
    ref_employee?: string | undefined;
    national_registration_number?: string | undefined;
    login?: string | undefined;
    gender?: string | undefined;
    admin?: number | undefined;
    address?: string | undefined;
    zip?: string | undefined;
    town?: string | undefined;
    country_id?: number | undefined;
    state_id?: number | undefined;
    office_phone?: string | undefined;
    office_fax?: string | undefined;
    user_mobile?: string | undefined;
    email?: string | undefined;
    job?: string | undefined;
    signature?: string | undefined;
    accountancy_code?: string | undefined;
    note_public?: string | undefined;
    note_private?: string | undefined;
    ldap_sid?: string | undefined;
    fk_user?: number | undefined;
    fk_user_expense_validator?: number | undefined;
    fk_user_holiday_validator?: number | undefined;
    employee?: string | undefined;
    thm?: string | undefined;
    tjm?: string | undefined;
    salary?: string | undefined;
    salaryextra?: string | undefined;
    weeklyhours?: string | undefined;
    color?: string | undefined;
    dateemployment?: string | undefined;
    dateemploymentend?: string | undefined;
    datestartvalidity?: string | undefined;
    dateendvalidity?: string | undefined;
    birth?: string | undefined;
    fk_warehouse?: number | undefined;
    lang?: string | undefined;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.module = _data["module"];
            this.id = _data["id"];
            this.entity = _data["entity"];
            this.civility_code = _data["civility_code"];
            this.lastname = _data["lastname"];
            this.firstname = _data["firstname"];
            this.ref_employee = _data["ref_employee"];
            this.national_registration_number = _data["national_registration_number"];
            this.login = _data["login"];
            this.gender = _data["gender"];
            this.admin = _data["admin"];
            this.address = _data["address"];
            this.zip = _data["zip"];
            this.town = _data["town"];
            this.country_id = _data["country_id"];
            this.state_id = _data["state_id"];
            this.office_phone = _data["office_phone"];
            this.office_fax = _data["office_fax"];
            this.user_mobile = _data["user_mobile"];
            this.email = _data["email"];
            this.job = _data["job"];
            this.signature = _data["signature"];
            this.accountancy_code = _data["accountancy_code"];
            this.note_public = _data["note_public"];
            this.note_private = _data["note_private"];
            this.ldap_sid = _data["ldap_sid"];
            this.fk_user = _data["fk_user"];
            this.fk_user_expense_validator = _data["fk_user_expense_validator"];
            this.fk_user_holiday_validator = _data["fk_user_holiday_validator"];
            this.employee = _data["employee"];
            this.thm = _data["thm"];
            this.tjm = _data["tjm"];
            this.salary = _data["salary"];
            this.salaryextra = _data["salaryextra"];
            this.weeklyhours = _data["weeklyhours"];
            this.color = _data["color"];
            this.dateemployment = _data["dateemployment"];
            this.dateemploymentend = _data["dateemploymentend"];
            this.datestartvalidity = _data["datestartvalidity"];
            this.dateendvalidity = _data["dateendvalidity"];
            this.birth = _data["birth"];
            this.fk_warehouse = _data["fk_warehouse"];
            this.lang = _data["lang"];
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["module"] = this.module;
        data["id"] = this.id;
        data["entity"] = this.entity;
        data["civility_code"] = this.civility_code;
        data["lastname"] = this.lastname;
        data["firstname"] = this.firstname;
        data["ref_employee"] = this.ref_employee;
        data["national_registration_number"] = this.national_registration_number;
        data["login"] = this.login;
        data["gender"] = this.gender;
        data["admin"] = this.admin;
        data["address"] = this.address;
        data["zip"] = this.zip;
        data["town"] = this.town;
        data["country_id"] = this.country_id;
        data["state_id"] = this.state_id;
        data["office_phone"] = this.office_phone;
        data["office_fax"] = this.office_fax;
        data["user_mobile"] = this.user_mobile;
        data["email"] = this.email;
        data["job"] = this.job;
        data["signature"] = this.signature;
        data["accountancy_code"] = this.accountancy_code;
        data["note_public"] = this.note_public;
        data["note_private"] = this.note_private;
        data["ldap_sid"] = this.ldap_sid;
        data["fk_user"] = this.fk_user;
        data["fk_user_expense_validator"] = this.fk_user_expense_validator;
        data["fk_user_holiday_validator"] = this.fk_user_holiday_validator;
        data["employee"] = this.employee;
        data["thm"] = this.thm;
        data["tjm"] = this.tjm;
        data["salary"] = this.salary;
        data["salaryextra"] = this.salaryextra;
        data["weeklyhours"] = this.weeklyhours;
        data["color"] = this.color;
        data["dateemployment"] = this.dateemployment;
        data["dateemploymentend"] = this.dateemploymentend;
        data["datestartvalidity"] = this.datestartvalidity;
        data["dateendvalidity"] = this.dateendvalidity;
        data["birth"] = this.birth;
        data["fk_warehouse"] = this.fk_warehouse;
        data["lang"] = this.lang;
        return data;
    }
}

export interface IUserDto {
    module?: string | undefined;
    id?: number;
    entity?: string | undefined;
    civility_code?: string | undefined;
    lastname?: string | undefined;
    firstname?: string | undefined;
    ref_employee?: string | undefined;
    national_registration_number?: string | undefined;
    login?: string | undefined;
    gender?: string | undefined;
    admin?: number | undefined;
    address?: string | undefined;
    zip?: string | undefined;
    town?: string | undefined;
    country_id?: number | undefined;
    state_id?: number | undefined;
    office_phone?: string | undefined;
    office_fax?: string | undefined;
    user_mobile?: string | undefined;
    email?: string | undefined;
    job?: string | undefined;
    signature?: string | undefined;
    accountancy_code?: string | undefined;
    note_public?: string | undefined;
    note_private?: string | undefined;
    ldap_sid?: string | undefined;
    fk_user?: number | undefined;
    fk_user_expense_validator?: number | undefined;
    fk_user_holiday_validator?: number | undefined;
    employee?: string | undefined;
    thm?: string | undefined;
    tjm?: string | undefined;
    salary?: string | undefined;
    salaryextra?: string | undefined;
    weeklyhours?: string | undefined;
    color?: string | undefined;
    dateemployment?: string | undefined;
    dateemploymentend?: string | undefined;
    datestartvalidity?: string | undefined;
    dateendvalidity?: string | undefined;
    birth?: string | undefined;
    fk_warehouse?: number | undefined;
    lang?: string | undefined;
}

export class WarehouseDto implements IWarehouseDto {
    id?: number;
    label?: string | undefined;
    description?: string | undefined;
    address?: string | undefined;
    town?: string | undefined;
    zip?: string | undefined;
    phone?: string | undefined;

    constructor(data?: IWarehouseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.label = _data["label"];
            this.description = _data["description"];
            this.address = _data["address"];
            this.town = _data["town"];
            this.zip = _data["zip"];
            this.phone = _data["phone"];
        }
    }

    static fromJS(data: any): WarehouseDto {
        data = typeof data === 'object' ? data : {};
        let result = new WarehouseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["label"] = this.label;
        data["description"] = this.description;
        data["address"] = this.address;
        data["town"] = this.town;
        data["zip"] = this.zip;
        data["phone"] = this.phone;
        return data;
    }
}

export interface IWarehouseDto {
    id?: number;
    label?: string | undefined;
    description?: string | undefined;
    address?: string | undefined;
    town?: string | undefined;
    zip?: string | undefined;
    phone?: string | undefined;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}